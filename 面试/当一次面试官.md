### useImperativeHandle 这个钩子是干嘛的 ？（引出函数组件类组件区别）

`useImperativeHandle` 是 React 的一个 Hook，用于在函数组件中暴露一个特定的子组件接口，使得父组件可以通过 ref 访问子组件的方法和属性。

一般来说，React 组件的外部接口是通过 props 来实现的，父组件可以通过 props 传递数据和函数给子组件，从而控制子组件的行为和状态。但是在某些情况下，父组件需要调用子组件的方法，或者访问子组件暴露出来的属性，这时候就可以使用 `useImperativeHandle` 钩子来实现。

`useImperativeHandle` 接受两个参数，第一个参数是一个 ref 对象，用于引用子组件；第二个参数是一个回调函数，用于返回一个对象，该对象中包含了子组件暴露给父组件的方法和属性。

当父组件通过 ref 访问子组件时，可以得到该对象，并调用其中的方法和属性。这种方式的好处在于，父组件只能访问到子组件暴露出来的接口，而不能访问到子组件的内部实现，从而保持了组件的封装性和隔离性。

比如说，我在使用`BetterScorll`这个库的时候，父组件需要使用到子组件里面，`Bscorll`实例    的方法。`useImperativeHandle`来暴露出`Bscorll`实例和一些实例方法。

这样可以提高代码的复用性和灵活性，同时也可以避免直接使用第三方组件库的限制和不足。

### 函数组件和类组件的异同？

![Lark20201208-185707.png](https://s0.lgstatic.com/i/image/M00/7E/CE/CgqCHl_PXDiAO20DAABdvYlGsmA577.png)

**相同点：** 使用体验

组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。

我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。

**不同点：**  使用场景、独有的功能、设计模式及未来趋势

- 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 `immutable`、没有副作用、引用透明，`hooks`有`Capture Value`等特点。
- 没有`hooks`之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于` React Hooks` 的推出，生命周期概念的淡出，函数组件可以取代类组件大部分功能了。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。类组件在书写业务逻辑上，代码总是分散在各个生命周期。但是函数组件确实在一个地方聚集。
- 性能优化上，类组件主要依靠` shouldComponentUpdate `阻断渲染来提升性能，而函数组件依靠` React.memo` 缓存渲染结果来提升性能。
- 从上手程度而言，类组件更容易上手，从未来趋势上看，由于` React Hooks` 的推出，函数组件成了社区未来主推的方案。
- 类组件在未来时间切片与并发模式中，由于this 的模糊性，业务逻辑散落在生命周期中，生命周期带来的复杂度，React 的组件代码缺乏标准的拆分方式并不易于优化。而函数组件本身轻量简单，且在 `Hooks` 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应` React` 的未来发展。

**可能补刀：**

什么是函数式编程？你怎么看待这种心智模式？

### 函数组件类组件使用ref的区别？为什么

**函数组件**

在函数组件中使用 ref 时，要区分两种情况：一种是使用 `React.forwardRef` 来包装函数组件，使其支持被父组件通过 ref 访问，另一种是使用 `useRef` 钩子在函数组件中使用 ref。

1. 使用 `React.forwardRef` 包装函数组件

在函数组件内部，我们可以使用 `React.forwardRef` 函数将组件包装起来，从而使其支持被父组件通过 ref 访问。具体使用方式是：定义一个函数组件（例如 `MyComponent`），然后将其作为 `React.forwardRef` 函数的参数，并在这个函数中返回一个新的组件：

```jsx
const MyComponent = React.forwardRef((props, ref) => {
  // ...
  return <div ref={ref}>Hello, World!</div>;
});
```

在这个新的组件中，我们将 `ref` 属性直接传递给了内部的 DOM 元素。当父组件通过 ref 访问这个子组件时，就可以得到这个 DOM 元素并调用其相应的方法和属性。

使用 `React.forwardRef` 包装函数组件时，需要注意以下几点：

- 在包装函数内部，必须使用 `forwardedRef` 属性将 ref 传递给内部的组件

- 如果组件中有多个可被 ref 访问的元素，需要使用 `React.useImperativeHandle` 钩子将相应的方法和属性暴露给父组件，避免非必要的暴露和修改内部实现
2. 使用 `useRef` 钩子在函数组件中使用 ref

在函数组件中，可以使用 `useRef` 钩子来创建一个 ref 对象，在内部的 JSX 中通过 `ref` 属性将其绑定到某个 DOM 元素上，从而实现访问这个 DOM 元素的方法。

```jsx
function MyComponent(props) {
  const myRef = React.useRef(null);

  const handleClick = () => {
    console.log(myRef.current.textContent);
  };

  return (
    <div ref={myRef} onClick={handleClick}>
      Hello, World!
    </div>
  );
}
```

在使用 `useRef` 钩子时，需要注意以下几点：

- 创建的 ref 对象一般都是 null 初始值，需要在 JSX 中将其绑定到某个 DOM 元素上，才能访问到该元素的方法和属性
- 访问 DOM 元素的方法通常是在函数组件中定义一个事件处理函数，该函数中使用 `myRef.current` 访问 DOM 元素的属性或方法，从而实现对其控制

在类组件中，使用ref属性可以访问组件实例或DOM元素。但是，在类组件上使用 ref 与在函数式组件上使用 ref 有一些不同之处。

在类组件上使用 ref 时，需要将 ref 绑定到组件实例上，例如：

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  componentDidMount() {
    console.log(this.refs.myRef); // 输出 <div>...</div>
  }
  render() {
    return <div ref={this.myRef}>Hello World!</div>;
  }
}
```

上述代码中，使用 React.createRef() 创建一个 ref 对象，并在组件的render方法中将其绑定到一个 div 元素上。这样，就可以通过 this.myRef.current 访问该元素的属性和方法。

另外，如果需要在类组件内部访问 ref，可以通过 this.refs 属性进行访问。

**类组件**

当在类组件中使用ref时，有两种不同的方法。

首先，使用字符串形式的ref已被弃用，因此不推荐使用。

相反，推荐使用回调形式的ref。在这种方式下，使用`createRef`创建一个ref对象并将其传递给组件的元素，然后在回调函数中接收组件的实例作为参数。这样，可以使用ref的`current`属性来引用组件的实例，并在自定义方法中进行操作。这种方式的优点是，可以清晰地访问实例，并且可以确保使用的是最新的实例。

在函数组件中，使用`useRef`钩子可以创建一个ref。这个ref对象可以用来引用函数组件中的DOM元素或其他组件实例。但是，在函数组件中不能使用字符串形式的ref，因为函数组件没有实例并且没有实例属性。相反，我们使用`useRef`钩子创建一个可变的ref对象，并将其传递给元素的ref属性。在自定义方法中，我们可以使用这个ref对象的`current`属性来引用元素实例。

与函数组件不同，类组件可以使用字符串形式的ref和回调形式的ref。使用字符串形式的ref已被弃用，因此不再推荐使用。相反，类组件现在推荐使用回调形式的ref。这种方式下，创建一个ref对象并将其传递给组件的元素，然后在回调函数中接收组件的实例作为参数。这样，可以使用ref的`current`属性来引用组件的实例，并在自定义方法中进行操作。

总之，函数组件与类组件在使用ref时主要区别在于，函数组件不能使用字符串形式的ref，而类组件可以使用但不推荐；函数组件使用`useRef`钩子创建可变的ref对象，而类组件使用React提供的`createRef()`方法创建可变的ref对象。

### 你看过什么源码？Context这个东西有应用到你看的领域吗？（redux、react-router、formily等）

### 为什么使用 ref，知道react可控组件和非可控组件的区别吗？

使用ref的目的是能够直接获取或者操作组件实例或DOM元素以及其内部的属性和方法。这样可以方便我们进行一些特殊的操作，例如触发元素的原生事件、给元素添加样式等等。

而React可控组件和非可控组件的区别在于，可控组件的输入值受React状态控制，而非可控组件的输入值只受DOM自身状态控制。

具体来说，可控组件的输入值（如表单输入框的值）是由React的状态控制的。我们可以使用React提供的`value`属性和`onChange`事件将组件与状态关联起来，从而实现双向绑定的效果。

而非可控组件，其输入值（如普通的HTML表单元素）则是由DOM自身状态控制的。我们可以在需要时获取它们的值，但是不能像可控组件那样直接修改它们的值。

总之，使用ref可以方便我们对React组件实例和DOM元素进行操作，但是需要谨慎使用。而React控制组件和非控制组件的区别则决定于输入值的状态管理方式，从而影响到我们的数据流和组件的可预测性。

### 首屏渲染速度你是怎么测量的？

### 白屏优化有做过吗？指标是什么？

看的指标主要是页面首次渲染时间（FP，也称First Paint）和首次无白屏时间（FCP，也称First Contentful Paint）。通过Chrome浏览器的开发者工具`performance`来测量。

页面首次渲染时间指的是浏览器开始渲染页面的时间点与浏览器收到HTML文件的时间点之间的时间，也就是浏览器看到HTML文件并开始渲染页面的时间。

首次无白屏时间指的是页面渲染出第一块实质内容的时间点，也就是用户可以开始阅读或者交互的时间点。这个时间点标志着页面已经有所体验，用户不会看到白屏或者空白的页面。

我主要通过了

1. 图片懒加载，延迟加载图片，减少页面的首次加载时间。

2. 路由懒加载，配合是`react`的`Suspense`组件配合`lazy`实现。

3. 骨架屏加载，提前预加载一些页面的骨架结构，让用户感觉到页面已经有内容了，打破空白的感觉，从而缩短白屏时间。

### axios怎么拦截一个请求？有一个api（字节问过我）

### 知道promise.race和all吗？

### 看你项目用了useMemo，useMemo和useCallback区别，应用场景是什么？

### 知道pureComponent吗？和React.memo的区别？

PureComponent 表示一个纯组件，可以用来优化 React 程序，减少 render 函数执行的次数，从而提高组件的性能。

在 React 中，当 prop 或者 state 发生变化时，可以通过在 shouldComponentUpdate 生命周期函数中执行 return false 来阻止页面的更新，从而减少不必要的 render 执行。React.PureComponent 会自动执行 shouldComponentUpdate。

不过，pureComponent 中的 shouldComponentUpdate() 进行的是**浅比较**，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候 render 是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent 一般会用在一些纯展示组件上。

使用 pureComponent 的**好处**：当组件更新时，如果组件的 props 或者 state 都没有改变，render 函数就不会触发。省去虚拟 DOM 的生成和对比过程，达到提升性能的目的。这是因为 react 自动做了一层浅比较。

### 看你用了BetterScroll，里面涉及到translate3d() ，你知道什么是css硬件加速吗？

### 说一下浏览器的线程进程？（上一道题）

### 说说你对防抖节流的理解吧?，以及项目里面的应用？（说一下闭包）把作用域链、原型链、上下文栈拓展一下

### webpack的打包流程（必问）

http是应用层的协议，它传输层用的协议是什么？tcp协议，除了tcp还有什么？

tcp和udp的区别是什么？

udp用到的场景较多的是什么？

http状态码 500 200 304 404等

304的协商缓存，讲一下协商缓存？

项目是否上线？和队友协作的时候遇到的问题？比如在需求实现？如何和队友进行交流

不同模块之间的样式如何统一？

如何实现分页，登录退出，如何鉴权？token如何提前过期？项目的难点？

如何实现的富文本编辑？能够达到什么样的功能？

项目是否上线？和队友协作的时候遇到的问题？比如在需求实现？如何和队友进行交流

不同模块之间的样式如何统一？

如何实现分页，登录退出，如何鉴权？token如何提前过期？项目的难点？

如何实现的富文本编辑？能够达到什么样的功能？
