![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-04-10-18-04-43-image.png)

### 软技能

#### 自我介绍一下？

面试官您好，我叫xxx，是成都信息工程大学大三的学生。今天来应聘贵公司的前端开发实习生的岗位。

我大概是去年寒假接触前端，真正深入学习是在去年暑假自学前端到现在，我熟悉前端的三剑客，用的框架是React，然后也了解过js一些特性等。我有过一段在知乎2个多月的实习经历，当时主要负责对公的员工管理项目和面向运营开发的反作弊分析项目，在实习中我认识到了合理封装组件的好处，以及性能优化和规范的工作流程的重要性。我也喜爱写博客文章，同时也开发了一个个人的音乐网站项目，这个项目比较好的亮点的话是我做较多的性能优化，让用户体验感得以提升。然后我希望就是能找到一份暑期实习，能让我继续在实践中锻炼自我，然后进一步提高自己的能力。

#### 你为什么学前端？

#### 你怎么学前端的

#### 最近学了什么新技术，接触新技术，如何学习

#### 未来的职业规划？

#### 了解过前端前沿技术吗（微前端，低代码）

### 实习项目

#### 简单介绍一下天枢？

这个项目主要是用于内部员工的管理，我负责的是绩效模块，用于员工对自己绩效的查看申诉和管理人员对员工绩效的创造等等。主要分为绩效方案，绩效结果，待确认绩效，历史绩效的增删改查。

其中绩效方案是一个比较复杂的表格嵌套表单，涉及到不同的公式配置等6个表单。由于涉及表单新建，编辑等不同状态下差异性置灰和样式布局（**背景**） ，如果是不封装就必须根据不同的表单类型来重新写一套colums来设置不同的disabled属性（**为什么封装**）。于是我自己封装了一个通用表单组件。实现了一套代码展示不同类型表单的效果，以及表单的通用默认布局。**（结果）**

#### 那说一下你是怎么封装通用表单组件的？

1. 首先我使用了Context来存储表单的类型将From组件包裹，通过Context.Provider来将表单类型传递给子组件，确认表单是编辑，新建还是详情状态。

2. 然后我使用了`useImperativeHandle`钩子来暴露一些表单操作方法，例如setFieldsValue、validateFields、resetFields、isFieldTouched和getFieldValue等。也给组件的props包括表单类型（type）、子元素（children）、布局（layout）、表单项布局（formItemLayout）、标签对齐方式（labelAlign）和是否禁用（disabled）等设置了默认值。

3. 最后，组件使用forwardRef函数来将CommonFormPanel组件转发为一个可使用ref的组件，以便在父组件中使用上述暴露的表单操作方法。

#### 为什么用context，为什么不直接用枚举类型表示表单的状态，直接父子组件传参？

我选择使用 Context 的目的是为了避免在父子组件之间频繁传递状态，特别是在多层嵌套的情况下。而且，这种方式可以使通用表单组件更具通用性，更加具有扩展性，保证了以后需要添加嵌套表单类型状态的时候也可以扩展。如果使用枚举类型来表示表单状态，那么在多个组件之间传递时需要手动管理状态，会导致代码冗余和维护困难。同时，使用 Context 还可以更好地支持复杂场景下的共享状态，比如组件库中可能存在多个表单组件或者子组件嵌套的情况。因此，使用 Context 是更加优秀的方案。

当面试官追问如何设计表单状态时，我可以进一步说明，如果状态比较简单并且只有一个组件会用到，枚举类型也是一个可选方案，但是当组件的逻辑复杂或者状态需要在多个组件之间共享时，使用 Context 更加的优秀，而且不会破坏 React 数据流的特性。最后，我可以解释使用 Context 的具体实现方式，以及它的优缺点。

#### 我们什么时候会使用ref，你的标准是什么

在 React 中，ref 是操作 DOM 的一个重要手段，用于获取组件实例或访问 DOM 元素。一些情况下我们需要直接操作或者访问 DOM 元素，比如：

- 获取某个组件内部的 DOM 元素，从而更精确地控制组件的行为和样式；
- 在表单中获取输入框的值、焦点及其他相关信息；
- 对于一些第三方库的组件，无法通过 props 直接操作它暴露的样式和属性，在这种情况下，我们可以使用 ref 定位它的 DOM 节点，然后通过 DOM API 直接操作它。

我的标准是，只在必要时使用 ref，因为过多地使用 ref 将打破 React 的数据流动一致性，并且可能使代码更难维护和测试。一般来说，我们可以使用 state 和 props 来管理组件的行为和状态，而不需要使用 ref，只有在必要时才使用它，这样可以保持代码的清晰和可维护性。同时，我也会避免过多地嵌套 ref，以避免组件树的深度和性能问题。

#### 如何实现差异化置灰效果的？

因为新建，编辑，查看的页面有着不同的置灰要求，并且还可以根据勾选框进行取消置灰，直接给Form组件本身增加disabled属性会导致置灰不完全，比如input输入框（**why**）于是使用context为表单设置表单类型状态包裹Form组件。（**how**）这里是Table和Form组件配合使用，通过表单类型和动态化columns可以通用一套columns，也实现在columns里面为input输入框设置置灰，减少代码量，（**what**）

#### 使用antd Form和Table组件嵌套的时候，为什么直接给Form组件本身增加disabled属性会导致置灰不完全，比如input输入框？

这是因为在 Ant Design 中，Form 和 Table 组件会自动为表单项的 DOM 元素添加属性和样式，以使其达到表单控件和标签对齐、宽度占满等效果。而直接给 Form 组件本身添加 disabled 属性，会导致 Form 组件内的所有表单项都被禁用，包括 label 文本，从而使表单项无法对齐，标签字体变灰色，输入框也无法获取焦点。
解决这个问题的方法是，在 Form 组件内通过 API 设置表单项的 `disabled` 属性，而不是直接在 Form 组件本身设置。比如可以使用 `Form.Item` 组件包装每个表单项，然后在 `Form.Item` 组件上设置 `disabled` 属性，这样就只禁用了单个表单项，而保持了其他表单项的正常状态。

#### 那你说一下Form 组件 fields 的值的传递原理？

在 Ant Design 中，`Form` 组件维护一个表单数据的内部状态，并且会实时同步表单项的数据和这个内部状态。`Form` 中的 `fields` 属性可以用于指定表单项初始值和控制表单项的取值和赋值。

当表单数据发生变化时，`Form` 组件会自动更新表单项的值和表单数据的内部状态，并触发 `onValuesChange` 属性中指定的回调函数来处理新的表单数据。而当需要应用某个 `fields` 属性时，`Form` 组件会根据这个属性值来创建表单项的初始数据，并通过 `setFieldsValue` API 方法将这个初始值设置到表单项中。

当用户提交表单时，`Form` 组件会收集所有表单项的数据，并合并到表单数据的内部状态中，然后通过 `onFinish` 属性中指定的回调函数来处理表单数据的提交。

总的来说，`Form` 组件的 `fields` 属性是以内部状态和表单项之间双向数据绑定为原理进行数据传递的。通过这种方式，可以使表单数据的操作更加方便和高效。

通过 useForm 拿到 form 实例对象，设置到 Form 组件里，然后用 form.setFieldsValue 设置的字段值就能在 Form.Item 里取到。**原理**其实是使用了Context，有一个传递 form 对象的 context，Form 组件往其中设置值，Item 组件在根据name设置的路径去取其中的部分值。

#### context 的原理呢？

createCotnext 就是创建了一个 _currentValue、Provider、Consumer 的对象。

_currentValue 就是保存值的地方

Provider 是一种 jsx 类型，之后会转为对应的 fiber 类型，然后它的处理就是修改 _currentValue，也就是修改 context 值

Consumer 和 useCotnext 就是读取 _currentValue，也就是读取 context 值。

唯一要注意的是 Provider 处理每个节点之前会入栈 context，处理完会出栈，这样就能保证 context 只影响子组件。

[React Context 实现原理：它在 antd 源码里简直用的太多了 - 掘金](https://juejin.cn/post/7200002468460806205)

#### 说一下你是怎么封装 HTML 文本动态切换展示组件（待补充）

#### 封装成共用方法，有什么注意事项？如何做到共用方法的可扩展性

#### 简单介绍一下二郎神

这是一个给运营，产品使用的反作弊系统，我负责的模块的粉丝这块，主要是进行对不同用户的粉丝行为进行数据可视化的展示方便运营使用。

在这个项目由于存在大量图表，请求大量数据服务器压力大 **（背景）**，我在请求时机，和请求次数上做了适当的处理，切换组件时进行了缓存组件，首屏渲染时只进行基本的用户信息和粉丝行为图表的请求，其他详细的行为图表，都在拉动互动指标数据表区间，才进行请求  **（选择解决方法）**。

#### 那说一下你怎么解决后端压力的？

首次进入时，如果url上有查询信息，直接触发查询使用（useEffect监听，useSearchParams）来决定现在是否直接发起请求，以及查询请求只会触发基本不改动的信息，频繁改动的信息使用一个trigger变量控制。使用Antd的Tabs的destroyInactiveTabPane={false}来缓存不同的图表组件。并且为了数据的方便使用和维护，都在整个模块index入口文件使用context向子组件传递属性和回调函数。

#### 使用自定义hooks，减少繁杂的echarts配置，描述一下你是怎么自定义hooks的？

自定义 Hooks 作用是可以将组件之间共享的逻辑抽离出来，使得组件更加纯粹，更具可读性和可维护性，提高代码的复用性。

由于图表大多数配置是默认不变的，主要改变的是 series配置项里面的data因此我自定义的Hook，主要用于发送数据请求（在使用 useEffect 钩子监听 params 和 trigger 等传递的变量的变化，当 trigger 变量为 true 时，调用 run 方法发送数据请求）。根据请求结果，将每个数据项转化成 echarts 系列配置选项中的 data 属性，并按照数值大小排序。然后将数据进行加工排序，在合并默认设置的echarts 系列的 **seriesOptions** 配置选项返回出去。这样在请求数据时直接可以获得默认好的  **series配置项**  数据，并且配合封装的图表组件（已经设置看默认的baseOptions）实现控制数据推动图表展示改变，通过自定义 Hooks，我们可以将 Echarts 初始化和配置分离出来，让代码更加清晰易懂。

传入请求url，parmas -> 获得带有data数据的配置项，在配合好封装的线图，饼图等等，在不需要使用默认series配置项的时候就解构用data即可，需要使用时就直接使用默认series配置项。

#### 简单说一下你是怎么封装的通用图表组件？

对于不同的图表类型分别封装了通用饼图，曲线图。上面封装的hooks就是返回的 **series配置项，** 于是基本的图表组件就是封装的**基本配置项baseOptions。**

对于曲线图，由于业务需要展示不同时间量级的图表，封装组件我使用series配置项和x轴数据，默认选择项等等是外部动态传递来实现。 

#### 你对封装组件的理解？

封装组件是一种提高代码复用性，降低代码耦合度以及提高代码的可维护性的方式。将一些独立的、可复用的功能封装成一个组件，并暴露一些对外的接口，以供其他地方使用。具体来说，封装组件可以达到以下几个目的：

1. **复用性**：将一些相对独立的功能封装成一个组件，可以有效地提高这些功能的复用性，降低代码的重复度。

2. **封装参数**：通过参数传递的方式，可以在一个组件中封装不同的配置和数据，使得同一组件能够呈现出不同的功能和样式。

3. **解耦**：通过一个明确定义的接口，可以将组件与其他组件或业务逻辑代码解耦，使得修改组件不会影响其他代码的正常运行。

4. **易维护**：将各种功能进行封装，可以降低代码的复杂度，减少代码的冗余，提高代码的可维护性。

5. **易测试**：通过测试封装的组件可以有效地对组件的功能和 API 进行测试，减少代码测试的难度和成本。

在实际开发中，我们可以使用各种框架和库如 React、Vue 等进行组件的开发和封装，也可以根据具体的业务需求和开发语言进行选择。无论使用何种方式和工具，封装组件的目的都是为了提高代码的复用性、可维护性和可读性，使得开发更加高效、轻松和稳定。

#### 集成表格数据导出Excel表的功能并封装成公用方法？

将params 使用reduce拼接上url上，采用自己创建a标签，模拟触发按钮效果。

```
/**
 * csv文件导出
 */
export const exportFile = (url: string, params: any) => {
  if (!url) return;

  const args = Object.entries(params || {}).reduce(
    (a: any, [k, v]) => (v ? [...a, `${k}=${v}`] : a),
    [],
  );
  const suffix = args.join('&');
  const href = `${url}?${suffix}`;

  const aEle = document.createElement('a');
  aEle.setAttribute('href', href);
  document.body.appendChild(aEle);
  aEle.click();
  document.body.removeChild(aEle);
};
```

[JS 下载/导出 csv、excel、txt 、img等文件的方法总结 - 掘金](https://juejin.cn/post/6844903839628263432)

#### Antd组件里面Tabs缓存组件的原理？

Antd 的 Tabs 组件里的 `destroyInactiveTabPane` 属性设置为 `false` 后，代表标签页无需每次切换时都重新渲染。此时，如果多次切换同一个标签页，前一次渲染出的组件不会被卸载，而是被缓存（保留 DOM 状态）。

底层实现原理是在 Tabs 组件中引入了 `rc-tabs` 基础包。在 `rc-tabs` 中，每次切换标签页后，会将要隐藏的标签页销毁（已完成 unmount），将要显示的标签页进行渲染和显示。

当 `destroyInactiveTabPane` 属性设置为 `false` 时，`rc-tabs` 会将将要隐藏的标签页进行卸载，而不是销毁，卸载后的标签页会被缓存。在下一次再次切换到该标签页时，会将卸载前的缓存重新挂载（remount）到 DOM Tree 中。

这种缓存组件的方式，可以提高标签页切换的性能，但是需要注意在卸载组件时，需要手动清理组件的定时器或绑定的事件等，否则可能会造成内存泄漏问题。同时也需要注意，如果缓存的组件本身拥有过多或占用过多内存，这种缓存方式可能会对网页性能造成不良影响。通常建议仅在组件轻量、易用、反复使用并且占用内存较小的情况下使用此项特性。

#### 说说对React中context的理解，有可替代方案（Dva等）吗？

React 中的 context 是一种跨组件层级传递数据的方式。它可以让父组件向子组件传递数据，而无需在每一个子组件中显式地通过 props 的形式传递数据。Context 可以被看作是组件树上的全局变量。

使用 Context 时，我们定义一个 Context 对象，可以通过 React.createContext 方法创建。Context 对象中包含两个组件：Provider 和 Consumer。Provider 用于设置 Context 的值，Consumer 用于获取 Context 的值。当 Context 值发生改变时，所有使用该 Context 的组件都会自动更新。

Dva 是一个类 Redux 的应用框架，提供了更多的约定和自动化的流程，以简化 Redux 的使用，并添加了一些额外的功能和插件。在 Dva 中，可以使用 Model 中的 state 来解决跨组件传递数据的问题，这类似于使用 Redux 中的 Store 来管理数据。在 Model 中保存的数据可以被整个应用中的组件共享和访问，而无需使用 Context 或 props 进行传递。

相较于使用 Context，Dva 可以更好地解决组件层级嵌套较深时，Context 数据传递行为变得复杂难以理解的问题。但 Context 也有自己的优点，例如，它可以更加灵活地传递数据；它是 React 自带的 API，无需引入额外的依赖，并且可以与 React 官方的工具协同工作。

因此，在实际使用中，我们需要根据具体场景来选择合适的数据传递方案。在数据传递行为简单的场景下，Context 能够带来极大的便利；而在数据传递行为复杂且需要更完整状态管理的场景下，Dva 的使用可能更适合。

#### Echarts了解到什么程度，底层是用canvas和re-render

#### 说一下实习的代码规范，现在接手项目的分支管理规范是怎样的?？

#### chrome中怎么调试 => f12\devtools插件

#### 项目里的登录功能是怎么实现的？项目里关于权限控制这块怎么做的？有了解哪些权限控制的方式？或者说更优雅地进行权限控制？

#### 说一下你对业务的理解

#### 实习公司的业务领域和产品是什么？你在其中扮演的角色是什么？

公司的业务主要是toB的，主要的产品使用对象是运营和产品，对内有管理员工，对外有知乎线上内容数据审核，处理等等。我扮演前端开发的角色，主要根据产品提出的rfc文档要求，和后端一起协商之后进行适当的计划与评估，出色的完成任务。

#### 你在实习期间遇到的最大挑战是什么？你是如何解决的？

技术上：挑选上面项目难点，比如表单封装，hooks自定义。

业务上：多和产品，后端进行细致的沟通，很多时候好的沟通往往就是高效工作的保障。然后举例，比如和后端沟通接口返回的数据格式，直接根据后端返回的数据一步渲染表头，表体。和产品适当勇敢提出业务需求的不合理或者建议。

#### 你在实习期间完成了哪些具体的项目或任务？你在其中负责的部分是什么？你的成果和贡献是什么？

一个人独立的完成了产品交付的较大需求模块，主要负责绩效模块，反作弊模块粉丝分析，主要成果封装了通用的组件，和自定义hooks复用，大大提高了开发效率。

#### 你在实习期间使用了哪些前端技术和工具？你是如何学习和使用它们的？你的技能水平如何？

学习了基本的联调，测试，部署流程。以及基本的git协作。

#### 你对前端技术或者前端行业的发展有什么看法或者想法？你是否有在业余时间学习或者研究前端相关内容？

前端现在发展十分迅猛，各大框架，低代码满天飞，在关注技术爆炸的同时不能浮与表面，然后说自己平时经常看书，写博客，举出自己看了axios源码，一些react原理什么的。

#### 遇到的最大困难,沟通上遇到过那些问题，前端后端的接口文档是你在负责吗？你对这种前后端对接的工作有什么心得吗？

### 音乐项目

#### 介绍一下网易云项目

因为自己也会挺喜欢听音乐的，所以想实现一个个人网易云，来用自己的网易云来听音乐。

我主要实现了歌手歌曲的基本展示，和播放器播放的功能。

**在业务实现上：** 在项目中我都对axios进行了封装，提高了开发体验（自定义 axios 拦截器针对请求参数和响应结果进行拦截处理）并且主要对 **性能优化上** 做了些许处理，让用户的体验感得到满足。

**主要对性能优化方案有:**

比如使用骨架屏和路由懒加载提升首屏渲染速度，以及用户操作中的一些优化，比如搜索上的防抖，无限滚动加载动画，图片的懒加载，长列表虚拟滚动等等。

#### 项目里面为什么使用axios能说说吗？用axios做了哪些事情？，拦截器的执行顺序？

Axios 是一个流行的基于 Promise 的 HTTP 库，它可以在浏览器端和 Node.js 中发送 HTTP 请求。使用 Axios 的优点有：

1. 支持浏览器和 Node.js。Axios API 支持浏览器和 Node.js，因此可以在前后端分离的项目中一致地发送 HTTP 请求，并且不需要多种不同的库。

2. 支持 Promise。Axios 的 API 基于 Promise，使得我们能够使用 Promise 的特性，例如 async/await。

3. 更友好的 API。相对于其他的 HTTP 库，Axios 的 API 更加容易使用和理解，例如设置拦截器、设置请求和响应拦截器等。

4. 功能更强大。Axios 提供了许多可定制的选项和功能，例如设置请求和响应的拦截器、支持文件的上传和下载、支持取消请求、xsrf 防御等，这些功能可以帮助我们更好地控制 HTTP 请求。

综上所述，使用 Axios 可以带来更好的 API 设计，更高效的性能表现，更好的扩展性以及更丰富的特性和选项，这些都使得它成为前后端分离项目中的理想选择。因此，在项目中选择使用 Axios 是一个合理的选择。

#### 能说说axios具体是怎么封装的吗？项目里怎么封装请求的?

当我们使用 Axios 发送一个请求时，我们需要配置请求的方法（GET、POST 等）、地址、请求头、请求数据等，这些配置都是通过 Axios 提供的 API 来完成的。在实际项目中，我们可能需要对 Axios 进行一些定制和封装，例如添加请求和响应的拦截器、封装通用的请求和错误处理、设置 baseURL 等。

在项目中，我们使用 `axios.create` 方法创建了一个 Axios 实例 `instance`，并设置了公共的 `baseURL` 地址和请求超时时间。接着，我使用 `instance.interceptors.request` 和 `instance.interceptors.response` 添加了请求和响应的拦截器，以便添加或处理请求头、响应数据以及通用的错误处理，将请求错误的状态码，请求超时等等信息打印出来。最后，我通过封装通用的 `get` 和 `post` 方法来简化发送请求的过程。

#### 用过fetch吗?fetch和axios的区别知道吗?

**1、最大的不同:**

**最大的不同点在于Fetch是浏览器原生支持，而Axios需要引入Axios库。**

**2、兼容性方面**

Axios可以兼容IE浏览器，而**Fetch在IE浏览器和一些老版本浏览器上没有受到支持**，但是有一个库可以让老版本浏览器支持Fetch即它就是whatwg-fetch，它可以让你在老版本的浏览器中也可以使用Fetch，并且现在很多网站的开发都为了减少成本而选择不再兼容IE浏览器。

**3、响应超时**

Axios的相应超时设置是非常简单的，直接设置timeout属性就可以了，而Fetch设置起来就远比Axios麻烦，这也是很多人更喜欢Axios而不太喜欢Fetch的原因之一。

**4、对数据的转换**

Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168028911-84fe2da0-bfe4-4130-8ee4-0e8309c630de.png)

5、拦截器

Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到。

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168069438-bbc3cedc-e011-4734-a896-f14ac5a1ae78.png)

最后附带上一些想法:

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168120392-7de5cdbe-ec8b-4184-a58b-2beb97c8bb91.png)

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168149928-58f3b73d-72ec-48b5-8e09-6a6030b33806.png)

#### 下拉刷新怎么做的？下拉刷新的原理有去了解吗？

`BetterScroll` 组件是通过监听 touch 事件来实现滚动的。当用户在 `BetterScroll` 组件中进行滚动操作时，`BetterScroll` 组件会触发了一系列特定的事件。我是在`betterScroll`里面注册了`touchEnd`，`scrollEnd`来分别监听用户的上拉，下滑滚动行为。根据y轴当前的值和maxScrollY等进行比较触发传入的回调函数，触发更新请求更新页面，为了用户体验，我添加了loading画面，用于过度数据加载，同时为了防止用户频繁触发，我也采用了防抖，以及`useMemo`处理回调函数。

[API | BetterScroll 2.0](https://better-scroll.github.io/docs/zh-CN/guide/base-scroll-api.html#%E5%B1%9E%E6%80%A7)

#### betterScroll的原理？为什么使用它？

**为什么使用？**

1. `BetterScroll` 运用了回流（reflow）与重绘（repaint）技术对页面进行优化，以使滑动过程更加流畅。

2. `BetterScroll` 通过拦截 touch 事件的方式，获取用户的滑动输入，并通过动态计算滑动的速度和加速度，来动态调整滚动位置和滚动速度。当滚动位置需要更新时，`BetterScroll` 会计算差值，并使用 CSS3 动画效果实现滚动动画。

3. `BetterScroll` 通过防抖技术来保证滑动事件的流畅度。如果用户连续滑动，事件处理函数将不会立即执行，而是等待一段短暂的时间，直到用户停止滑动为止。

4. `BetterScroll` 还提供了下拉刷新和上拉加载更多功能，这些功能通过监听特定的滚动事件，来实现对页面数据的动态更新。

5. `BetterScroll` 还提供了灵活的配置选项，可以让你自定义滚动时的行为和动画效果。

总之，`BetterScroll` 的核心原理是拦截并优化用户滑动输入，同时使用动态计算和 CSS3 动画实现滚动效果。其在滚动性能、流畅度和可定制性方面的优势，让它成为了现代 Web 应用中不可或缺的一部分。

**原理**

在 `BetterScroll` 中，`translateY()` 和 `translate3d()` 是主要用于控制滚动位置的 `transform` 属性中的方法。其中，`translateY()` 可以在纵向滚动时使用，而 `translate3d()`可用于同时控制横向和纵向滚动。

具体实现的原理如下：

首先，通过设置父容器固定高度和 `overflow` 属性为 `hidden`，子元素的高度超出容器后会被隐藏，只有当子元素的高度大于父容器的高度时，滚动操作才有意义。

然后，通过监听 `touch` 事件，`BetterScroll` 可以获取用户的滑动输入，包括滑动开始、滑动过程和滑动结束等事件。通过计算这些滑动输入，包括滑动的速度和加速度，`BetterScroll` 可以实时调整子元素的位置和滚动速度，实现平稳的滑动效果。

在实时调整子元素位置时，`BetterScroll` 会通过修改 `transform` 属性中的 `translateY()` 或 `translate3d()` 方法的参数值，来控制子元素的垂直或水平方向上的偏移量。例如，当用户向上滑动时，`BetterScroll` 会将 `translateY()` 或 `translate3d()` 方法的参数值做减小操作，并设置边界值，避免子元素滚动超过父容器的范围。

- better-scroll 只处理容器（wrapper）的第一个子元素（content）的滚动，其它的元素都会被忽略。
- 外盒子设置固定宽或高和属性：overflow: hidden;，这里我默认使用的是宽高继承100%。
- 当 content的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动了，这就是 better-scroll 的滚动原理。

通过这种方式，`BetterScroll` 可以通过 `transform` 属性的实时调整，来实现对滚动位置的控制，从而实现流畅的滑动效果。同时，在 `translate3d()` 方法中，可以同时控制横向和纵向的偏移量，可以用于实现横向滚动和纵向滚动的组合效果。

绿色部分为 wrapper，也就是父容器，它会有固定的高度  
黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1646878841812-f795b4ba-bb9e-4fb8-ad9a-19777125ce88.png)

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1646878804676-bec37cf7-0746-42cb-8bb4-a83b92a28b7a.png)

#### 开发调试用过什么？移动端做过什么？怎么调试？

在前端开发中，我主要用过以下工具和方法来进行调试：

1. 浏览器开发者工具：浏览器开发者工具中提供了丰富的调试工具，比如 Console、Elements、Network、Sources 等面板。我们可以利用这些工具来查看页面结构、监控网络请求、调试 JavaScript 代码、修改样式等等。

2. VS Code 调试工具：VS Code 提供了非常强大的调试工具，可以用来调试 Node.js 应用、前端应用等等。我们可以通过配置调试选项，打断点、单步调试等等，来进行精确的调试。

3. Charles Proxy：Charles Proxy 是一款用于调试网络请求的工具，可以使用它来监控整个应用的网络请求，并且可以对请求和响应进行修改和复制等等操作。

4. 调试工具插件：比如 Redux DevTools、React Developer Tools 等，这些插件可以帮助我们调试某些特定的技术栈和工具。

总的来说，调试的主要流程可以分为以下几个步骤：

1. 定位问题：首先需要定位问题所在，查找报错信息、打印日志等等。

2. 复现问题：尽可能地复现问题，找到复现问题的具体步骤和条件。

3. 分析问题：通过调试工具和方法，对问题进行分析和定位，找出原因。

4. 解决问题：根据问题的具体原因，采取相应的解决方案来修复或优化代码。

在调试过程中，我们需要有耐心和细心，并且要尽可能地利用现有的工具和方法来提高调试效率和精度。

#### 性能优化过程和具体方法，如何监控性能指标，做性能优化的思路和过程，首屏渲染时间怎么看的？指标是啥？0.9s这个时间怎么看的？指标是啥？了解过有哪些与性能优化相关的工具吗？

首先我会使用使用 Chrome 开发者工具中的 Performance 和 Network 面板进行监控和分析，找出性能瓶颈，进行相应的优化。然后考虑大家使用的常规的优化手段，例如减少请求次数（使用路由缓存），减少重拍重绘（使用css动画，betterScorll滚动）等等。

在首屏渲染等等查看上我先是使用的浏览器自带的调试面版，以及`Performance-Analyser`，然后我自己还根据Performance API 写了一个各项性能指标计算的工具函数。

#### 你是怎么实现这个各项性能指标计算的工具函数的？

performance的API是浏览器暴露给js的一个接口，可以通过这个接口查看用户访问网站的连接建立时间、dns时间等信息。使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。于是我通过onload事件绑定了一个回调函数，根据 performance.timing的相关属性进行计算得到首屏渲染，重定向，DNS解析等等各项数据。其中白屏时间我主要是根据`time.domLoading - time.fetchStart`计算得来的。其他的大多也就是网上查询计算公式的得到的。

[性能优化——window.performance监测载入白屏时间 - 掘金](https://juejin.cn/post/7054521713748344869)

#### 项目里路由懒加载如何实现的？原理是什么？还有其他的方法吗？

为什么要使用路由懒加载?

当刚运行项目的时候，发现刚进入页面，就将所有的js文件和css文件加载了进来，这一进程十分的消耗时间。 如果打开哪个页面就对应的加载响应页面的js文件和css文件，那么页面加载速度会大大提升。

路由懒加载一定会提高页面加载速度吗，什么时候用路由懒加载

**懒加载的好处是什么?**

懒加载简单来说就是webpack将代码拆分为多个bundle，同时可以按需或者并行加载。因此，为了提高应用的性能，即在需要的时候的时候进行加载。我们可以尝试如何合理的分割代码并延迟加载。

**怎么使用的路由懒加载?**

使用到的是es6的import语法，可以实现动态导入

```
const Search = lazy(() => import("./../application/Search"));

const SuspenseComponent = Component => props => {
    return (
        <Suspense fallback={<Skeleton />}>
            <Component {...props}></Component>
        </Suspense>
    )
}

{
    path: '/search',
    exact: true,
    component: SuspenseComponent(Search),
}
```

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1646967987267-e6df2d9c-db4f-42da-ba3d-280af9a312e3.png)

**路由懒加载的原理是什么?**

webpack在编译时，识别到动态加载的import语法，则webpack会为当前动态加载的模块创建一个单独的bundle。如果你使用的是官方的Create-react-app脚手架或React的服务端渲染框架Next.js，那么可以直接使用动态import语法。如果你的脚手架是你自己配置的webpack，那么你需要按照官方指南来设置。

通过Webpack编译打包后，会把每个路由组件的代码分割成一一个js文件，初始化时不会加载这些js文件，只当激活路由组件才会去加载对应的js文件。

懒加载之后只有在激活的时候才会被加载吗？

作用就是webpack在打包的时候，对异步引入的库代码进行代码分割时（需要配置webpack的SplitChunkPlugin插件），为分割后的代码块取得名字

React中运用import的懒加载语句以及webpack的魔法注释，在项目进行webpack打包的时候，对不同模块进行代码分割，在首屏加载时，用到哪个模块再加载哪个模块，实现懒加载进行页面的优化。

[基于React.Suspense和React.lazy的前端性能优化 - 掘金

#### 项目里是怎么做打包的？,有对打包做过哪有优化？前端页面优化

答: 从请求和运行两方面考虑。
请求:压缩图片（埋下伏笔QAQ）、压缩代码、开启gzip/compress、懒加载、cdn、雪碧图、本地缓存...
运行:优化用户体验。减少重排、滚动优化、骨架屏、防抖节流...
用到的性能优化办法

#### 说说你对防抖节流的理解吧?，以及项目里面的应用？节流用在什么地方，自己的项目中用到了吗？如何实现？如何优化？

我在用户上拉下拉滚动页面的时候给回调函数添加了防抖的处理，防止频繁触发重复的请求，我也在搜索框的地方使用了防抖处理，将外部传入的搜索查询函数在组件内部进行防抖处理。

**防抖函数的应用场景：**

- 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
- 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce

**节流函数的适⽤场景：**

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
- 缩放场景：监控浏览器resize
- 动画场景：避免短时间内多次触发动画引起性能问题

#### 为什么要使用图片懒加载？懒加载原理？搭配betterScorll库的坑？

在一些图片比较多的网站（比如说大型电商网站）图片是非常多的，如果我们在打开网页的一瞬间就把网站的所有图片加载出来，很有可能造成卡顿和白屏的现象，用户体验变得极其的差。因为图片真的很多，一瞬间就把网站的所有图片加载出来浏览器短时间内根本处理不完，但是我们打开网站的那一瞬间仅仅只能看到视口内的图片，这时候去加载网页最底部的图片是非常浪费资源和没有必要的，所以遇到这种情况使用懒加载技术就显得尤为必要了。

我采用了一个`React-Lazyload`库来实现图片懒加载。它的原理是：在初次渲染时，只加载占位符，当页面滚动到图片可见区域时，再用 img 标签去加载真正的图片。

图片懒加载原理是在初始加载页面时，只加载页面上的可视区域内的图片。当用户向下滚动页面时，再去加载其他不可见区域的图片。

具体实现方式是，先将页面上需要懒加载的图片的src属性设为一个占位符，而真实的图片地址则保存在一个自定义的属性（比如data-src）中。然后在页面滚动事件中监听滑动的位置，判断哪些图片进入了可视区域，并将其自定义属性中的真实图片地址赋值给其src属性，从而实现图片的懒加载。

图片懒加载的优势在于减少了初始页面的图片加载量，以提高网页的初始加载速度。同时，图片懒加载也可以避免浪费用户的流量，因为仅加载可见的图片，而不是劣质的图片。

使用`IntersectionObserver`进行监控

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-04-12-16-18-43-image.png)

`onScorll`回调使用`forceCheck()`是`react-lazyload`提供的方法之一，可以手动触发懒加载检测并更新。

当使用懒加载的时候，组件会通过监听滚动事件，自动检测是否有需要加载但未加载的图片在viewport中，然后进行图片加载。但是，在某些情况下，需要在组件mounted之后即刻进行检测和加载，比如有些滚动库（如better-scroll）可以独立于DOM渲染之外，而懒加载库是无法感知这种情况的。这时候`forceCheck()`方法就可以派上用场了。

`forceCheck()`方法会遍历所有`react-lazyload`组件实例，强制重新检测是否需要加载图片。当我们提前将所有图片都加载出来时，可以使用该方法来关闭懒加载功能，提升页面加载速度和性能。例如，在better-scroll开始滚动之前，可以强制检查所有需要加载的图片，以保证滚动时图片已被加载。

#### 你能说说为啥使用骨架屏吗?骨架屏的原理？

现在的前端开发领域，都是前后端分离，前端框架主流的都是 SPA，这就意味着，页面渲染以及等待的白屏时间，成为我们需要解决的问题点；而且大项目，这个问题尤为突出。

webpack 可以实现按需加载，减小我们首屏需要加载的代码体积；再配合上 CDN 以及一些静态代码（框架，组件库等等…）缓存技术，可以很好的缓解这个加载渲染的时间过长的问题。但即便如此，首屏的加载依然还是存在这个加载以及渲染的等待时间问题；

- 提升用户体验，让用户获知当前页面的大体结构，比常见 loading 的视觉更加流畅
- 骨架屏内容的渲染，缩短了 FMP (First Meaningful Paint)，提升站点 / 应用性能

目前主流，常见的解决方案是使用**骨架屏**技术，包括很多原生的APP，在页面渲染时，也会使用骨架屏。（下图中，红圈中的部分，**即为骨架屏在内容还没有出现之前的页面骨架填充，以免留白**）

<img src="https://cdn.nlark.com/yuque/0/2022/png/23076793/1648442050477-950d07b6-3021-42da-9d6d-a4fe19e6b0cc.png" title="" alt="image.png" width="50">

为了减少首屏渲染的时间，我使用 [awesome-skeleton](https://github.com/kaola-fed/awesome-skeleton)自动生成骨架屏图片之后在index.html文件直接插入，在ReactDOM开始工作前先渲染页面出来。经过浏览器`Performance` 查看First Paint 时间缩短到0.9s以下。

```
const SuspenseComponent = Component => props => {
    return (
        <Suspense fallback={<Skeleton />}>
            <Component {...props}></Component>
        </Suspense>
    )
}
```

**方案一、**

在 index.html 中的 div#app 中来实现骨架屏，程序渲染后就会替换掉 index.html 里面的 div#app 骨架屏内容；

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647393523089-05d949c5-e96f-4b2b-bc36-8eb70ccfa1ca.png)

**方案二、使用一个Base64的图片来作为骨架屏**

使用图片作为骨架屏； 简单暴力，让UI同学花点功夫吧；小米商城的移动端页面采用的就是这个方法，它是使用了一个Base64的图片来作为骨架屏。

按照方案一的方案，将这个 Base64 的图片写在我们的 index.html 模块中的 div#app 里面。

**方案三使用现场的库**

#### 你在项目中遇到过哪些困难和挑战？你是如何解决的？你对项目中某个具体功能或者模块的实现过程有没有什么特别的见解或者想法？哪个项目是从头自己搭建的，整体搭建思路、流程、为什么选取这个技术栈,介绍一下项目，并说一下你认为最有成就感的一个点。

#### xxx组件你是怎么实现的？

#### 旋转动画实现，唱片CD的CSS3动画是怎么做的？

#### 口撕虚拟列表 用的第三方库还是自己实现，第三方库实现和自己实现有区别吗（待补充）

自己实现的，配合betterScorll的实例对象，进行`scorll`事件监听进行处理。根据滚动计算出新的end下标,增加渲染列表长度。

#### 什么是 RTK？RTK 框架中有哪些 API？React 是如何使用 Redux Toolkit 的？RTK 中 `createSlice` 方法有哪些参数？如何使用 RTK 处理异步请求？RTK 的实现原理是什么？RTK 和 Redux 的对比？

### 在线教育项目

#### 为什么选择`Sequelize`？不选择其他的ORM框架？

- 基于 promise 的 Node.js 的 ORM
- 支持多种数据库
- 具有强大的事务支持，关联关系，预读和延迟加载等功能
- 官网：[https://www.sequelize.com.cn](https://www.sequelize.com.cn)

sequelize 支持数据库多样，而且具有强大的事务支持，关联关系，预读和延迟加载等功能。比如添加一条评论，在评论总数也要+1，这2件事要么同时成功要么同时失败，这就保证了数据不会失败。 

#### Mysql常见的存储引擎你知道多少？

#### 你能说下为什么要使用第三方社交登录吗？

- 社交登录
  
  - 含义：访问某个网站的用户可以通过社交媒体账号登录
  
  - 优点
    
    - 可以利用社会化媒体的影响增加网站和用户粘性，提高留存
    - 借助分享、裂变等方式对网站进行推广，提高知名度 AARRR中的留存和传播
    - 同时增加网站的流量，使用量，提高网站产品的转换率
  
  - 类型
    
    - 腾信微信
    - 腾讯QQ
    - 阿里支付宝
    - 微博
    - .....
    
    微信登录分为
    
    - 场景二维码登录
    - Oauth2.0授权登录

#### 开发的图形验证码解决了什么问题？为了什么类型的安全性而使用验证码呢？

为什么要使用图形、滑块等验证码校验

- 随机生成四位或者其他位数的图形文本，人为才能轻松识别，机器程序识别比较困难，增加了恶意的人为或机器程序的攻击
- 防止程序被恶意大量高频的调用，给我们服务造成很多无效的注册或登录，占用自身服务器的内存资源

#### 图形验证码一定安全吗？

- 图形验证码一定安全吗？
  
  - 攻击与防御是一直都存在的，滑动验证码和图形验证码也都是可以被破解的（ocr），ip也是可以租用。
  - 增加攻击者的成本，降低被攻击的风险

#### 什么是短信盗刷，怎么防止？如何避免自己的网站成为“肉鸡”？

- 如何避免自己的网站成为“肉鸡”？
  
  - 增加图形验证码
  - 限制一个ip的获取验证码的次数
  - 限制号码发送，设置每个月每个号码可以发送多少条短信，降低短信套餐成本。

#### 说说你们项目几个时间节点
