### React SSR

### React 单向数据流

### React 父子组件传值

### hooks

### 函数式组件实现闭环

### hooks 相比 class 有什么优点

### 对 React SSR 的理解

服务端渲染是数据与模版组成的 html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成 html 字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的 body 里为空，之后执行 js 将 html 结构注入到 body 里，结合 css 显示出来;

**SSR 的优势：**

- 对 SEO 友好
- 所有的模版、图片等资源都存在服务器端
- 一个 html 返回所有数据
- 减少 HTTP 请求
- 响应快、用户体验好、首屏渲染快

**1）更利于 SEO**

不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了 React 或者其它 MVVM 框架之后，页面大多数 DOM 元素都是在客户端根据 js 动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行 JavaScript 脚本的最终 HTML，网络爬中就可以抓取到完整页面的信息。

**2）更利于首屏渲染**

首屏的渲染是 node 发送过来的 html 字符串，并不依赖于 js 文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。

**SSR 的局限：**

**1）服务端压力较大**

本来是通过客户端完成渲染，现在统一到服务端 node 服务去做。尤其是高并发访问的情况，会大量占用服务端 CPU 资源;

**2）开发条件受限**

在服务端渲染中，只会执行到 componentDidMount 之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;

**3）学习成本相对较高**  除了对 webpack、MVVM 框架要熟悉，还需要掌握 node、 Koa2 等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。

**时间耗时比较：**

**1）数据请求**

由服务端请求首屏数据，而不是客户端请求首屏数据，这是"快"的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网 http 请求开销大，导致时间差。

### 怎么解决 React 重复渲染 memo 应用场景 第二个参数

在 React 应用中，memo 是一种优化组件性能的方式，它可以避免组件在 props 没有变化时不必要的重新渲染。memo 函数使用了浅层比较来判断当前传入的 props 是否与之前传入的相同。如果相同，则 React 会复用之前的组件实例，从而避免了无谓的渲染操作。

然而，在某些场景下，即使父组件的 props 没有改变，memo 包装的子组件仍然会重新渲染。这通常是因为引用类型（数组、对象等）的值发生了变化，而这些值被作为 props 传递给了子组件，导致子组件也跟着重新渲染。

为了避免这种情况，React.memo() 函数提供了一个可选参数 `areEqual`，它允许我们自定义比较函数。如果传入了该属性，则 React 会调用这个函数来决定是否需要更新组件。这个函数接受两个参数：前一个 props 和后一个 props；如果这个函数返回 `true`，则 React 会认为这两个 props 是相等的，从而避免更新组件。反之则会更新。

例如，假设我们的子组件接受一个对象类型的 prop，我们可以通过以下方式来防止不必要的渲染：

```
function MyComponent(props) {
  // ...
}

function areEqual(prevProps, nextProps) {
  return prevProps.objectProp.id === nextProps.objectProp.id;
}

export default React.memo(MyComponent, areEqual);
```

在上面的例子中，我们传递了 `areEqual` 函数给 `React.memo()`，用来比较前后 props 是否相等。具体来说，我们使用了对象的 `id` 属性来作为比较依据，只有当 `id` 相等时才认为 props 不变。

总之，通过自定义 `areEqual` 比较函数，我们可以避免 memo 组件在某些情况下不必要的渲染，提高应用程序的性能和响应速度。

### React.memo 作用及实现

```
作用：为函数组件提供类似PureComponent的功能，调用方式
React.memo(Component, [isEqual])
其中isEqual方法的返回值与shouldComponentUpdate返回值相反
// 3种实现方式
// 函数式组件
function memo(Component, isEqual) {
  function MemoComponent(props) {
    const prevProps = React.useRef(props)
    React.useEffect(() => {
      prevProps.current = props
    })
    return React.useMemo(() => <Component {...props} />, [
      isEqual(prevProps.current, props),
    ])
  }
  return MemoComponent
}
// 使用PureComponent
function memo(Component, isEqual) {
  return class MemoComponent extends React.PureComponent {
    render() {
      return <Component {...this.props} />
    }
  }
}

// 使用shouldComponentUpdate
function memo(Component, isEqual) {
  return class MemoComponent extends React.Component {
    shouldComponentUpdate(prevProps) {
      return !isEqual(prevProps, this.props)
    }
    render() {
      return <Component {...this.props} />
    }
  }
}
```

### useCallback 和 useMemo 的区别？

`useCallback` 和 `useMemo` 都是 React Hooks 中用来优化性能的工具，它们之间的区别是：

1. **使用场景不同**：`useCallback` 主要是用来缓存函数以提升组件的渲染性能，而 `useMemo` 则是用来缓存计算结果以避免重复计算。
2. **返回值不同**：`useCallback` 返回一个 memoized（记忆化）的回调函数，而 `useMemo` 返回一个 memoized（记忆化）的计算结果。
3. **参数不同**：`useCallback` 接受两个参数：回调函数和依赖项数组，当依赖项发生变化时才会创建新的 memoized 的回调函数；而 `useMemo` 接受两个参数：计算函数和依赖项数组，当依赖项发生变化时才会重新计算出 memoized 的结果。

下面是一个例子，演示了 `useCallback` 和 `useMemo` 的差异：

```ts
import { useCallback, useMemo } from "react";

function MyComponent(props) {
  const { count, onClick } = props;

  const handleClick1 = () => {
    onClick(count + 1);
  };

  const handleClick2 = useCallback(() => {
    onClick(count + 1);
  }, [count]);

  const result = useMemo(() => {
    return count * 2;
  }, [count]);

  return (
    <div>
      <button onClick={handleClick1}>Click me (non-memoized)</button>
      <button onClick={handleClick2}>Click me (memoized)</button>
      <p>Result: {result}</p>
    </div>
  );
}
```

在这个例子中，`handleClick1` 是普通的函数，每次组件重新渲染时都会创建新的函数对象，而 `handleClick2` 是 memoized 的函数，只有当 `count` 发生变化时才会创建新的函数对象，从而避免了不必要的渲染。另外，`result` 是 memoized 的计算结果，只有当 `count` 发生变化时才会重新计算，也能够提高性能。

在面试中，如果被问到 `useCallback` 和 `useMemo` 的区别，可以根据上面提到的三个方面来回答。同时，可以举一些具体的实际场景来解释它们是如何使用的，并且强调它们对性能优化的重要性。

### react 与 vue 有什么不同

[Vue 与 React 的区别 - 掘金](https://juejin.cn/post/6847902224413097991)

### React 的 diff 算法

[ _React_ (四)_diff 算法_](http://www.bilibili.com/video/BV1uN4y1F7F7/)

[图解 React 的 diff 算法：核心就两个字 —— 复用 - 掘金](https://juejin.cn/post/7131741751152214030#heading-0)

[React 组件的性能优化 - 掘金](https://juejin.cn/post/7166180718236663845)

### state 和 props

**（1）props**

props 是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。

**（2）state**

state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。

**（3）区别**

- props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。
- props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。
- state 是在组件中创建的，一般在 constructor 中初始化 state。state 是多变的、可以修改，每次 setState 都异步更新的。

### React 中的 props 为什么是只读的？

`this.props`是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React 具有浓重的函数式编程的思想。

提到函数式编程就要提一个概念：纯函数。它有几个特点：

- 给定相同的输入，总是返回相同的输出。
- 过程没有副作用。
- 不依赖外部状态。

`this.props`就是汲取了纯函数的思想。props 的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用

### 类组件与函数组件有什么异同？

**相同点：** 组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。

我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。

**不同点：**

- 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。
- 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。
- 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。
- 从上手程度而言，类组件更容易上手，从未来趋势上看，由于 React Hooks 的推出，函数组件成了社区未来主推的方案。
- 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。

### useState, userRef 怎么使用。

[useState – React](https://react.docschina.org/reference/react/useState)

[useRef – React](https://react.docschina.org/reference/react/useRef)

### useState 原理

### 说一下你对 React 的理解

#### 1.React 是什么？
