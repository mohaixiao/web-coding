### 软技能

#### 自我介绍一下？

面试官您好，我叫xxx，是成都信息工程大学大三的学生。今天来应聘贵公司的前端开发实习生的岗位。

我学习前端大概一年左右，我熟悉前端的三剑客，技术栈是React，我了解js一些特性等。我在知乎和绿盟科技的实习过一段时间，当时主要负责对公的员工管理项目和面向运营开发的反作弊分析项目，在实习中我认识到了合理封装组件的好处，以及性能优化和规范的工作流程的重要性。我也喜爱写博客文章，同时也开发了一个包括前台和后台的在线课程项目，这个项目比较好的亮点的话是我做了三方登录，支付，以及SEO等等优化。我个人性格比较开朗，外向，最后感谢面试官抽出的宝贵的时间。

#### 你为什么学前端？

#### 你怎么学前端的

#### 最近学了什么新技术，接触新技术，如何学习

#### 未来的职业规划？

#### 了解过前端前沿技术吗（微前端，低代码）

### 实习项目

#### 简单介绍一下员工内部管理系统？

这个项目主要是用于内部员工的管理，我负责的是绩效模块，用于员工对自己绩效的查看申诉和管理人员对员工绩效的创造等等。主要分为绩效方案，绩效结果，待确认绩效，历史绩效的增删改查。

其中绩效方案是一个比较复杂的表格嵌套表单，涉及到不同的公式配置等6个表单。由于涉及表单新建，编辑等不同状态下差异性置灰和样式布局（**背景**） ，如果是不封装就必须根据不同的表单类型来重新写一套colums来设置不同的disabled属性（**为什么封装**）。于是我自己封装了一个通用表单组件。实现了一套代码展示不同类型表单的效果，以及表单的通用默认布局。**（结果）**

#### 那说一下你是怎么封装通用表单组件的？

1. 首先我使用了Context来存储表单的类型将From组件包裹，通过Context.Provider来将表单类型传递给子组件，确认表单是编辑，新建还是详情状态。

2. 然后我使用了`useImperativeHandle`钩子来暴露一些表单操作方法，例如`setFieldsValue`、`validateFields`、`resetFields`、`isFieldTouched`和`getFieldValue`等。也给组件的props包括表单类型（type）、子元素（children）、布局（layout）、表单项布局（formItemLayout）、标签对齐方式（labelAlign）和是否禁用（disabled）等设置了默认值。

3. 最后，组件使用forwardRef函数来将CommonFormPanel组件转发为一个可使用ref的组件，以便在父组件中使用上述暴露的表单操作方法。

#### 为什么用context，为什么不直接用枚举类型表示表单的状态，直接父子组件传参？

我选择使用 Context 的目的是为了避免在父子组件之间频繁传递状态，特别是在多层嵌套的情况下。而且，这种方式可以使通用表单组件更具通用性，更加具有扩展性，保证了以后需要添加嵌套表单类型状态的时候也可以扩展。如果使用枚举类型来表示表单状态，那么在多个组件之间传递时需要手动管理状态，会导致代码冗余和维护困难。同时，使用 Context 还可以更好地支持复杂场景下的共享状态，比如组件库中可能存在多个表单组件或者子组件嵌套的情况。因此，使用 Context 是更加优秀的方案。

当面试官追问如何设计表单状态时，我可以进一步说明，如果状态比较简单并且只有一个组件会用到，枚举类型也是一个可选方案，但是当组件的逻辑复杂或者状态需要在多个组件之间共享时，使用 Context 更加的优秀，而且不会破坏 React 数据流的特性。最后，我可以解释使用 Context 的具体实现方式，以及它的优缺点。

#### 我们什么时候会使用ref，你的标准是什么

在 React 中，ref 是操作 DOM 的一个重要手段，用于获取组件实例或访问 DOM 元素。一些情况下我们需要直接操作或者访问 DOM 元素，比如：

- 获取某个组件内部的 DOM 元素，从而更精确地控制组件的行为和样式；
- 在表单中获取输入框的值、焦点及其他相关信息；
- 对于一些第三方库的组件，无法通过 props 直接操作它暴露的样式和属性，在这种情况下，我们可以使用 ref 定位它的 DOM 节点，然后通过 DOM API 直接操作它。

我的标准是，只在必要时使用 ref，因为过多地使用 ref 将打破 React 的数据流动一致性，并且可能使代码更难维护和测试。一般来说，我们可以使用 state 和 props 来管理组件的行为和状态，而不需要使用 ref，只有在必要时才使用它，这样可以保持代码的清晰和可维护性。同时，我也会避免过多地嵌套 ref，以避免组件树的深度和性能问题。

#### 如何实现差异化置灰效果的？

因为新建，编辑，查看的页面有着不同的置灰要求，并且还可以根据勾选框进行取消置灰，直接给Form组件本身增加disabled属性会导致置灰不完全，比如input输入框（**why**）于是使用context为表单设置表单类型状态包裹Form组件。（**how**）这里是Table和Form组件配合使用，通过表单类型和动态化columns可以通用一套columns，也实现在columns里面为input输入框设置置灰，减少代码量，（**what**）

#### 使用antd Form和Table组件嵌套的时候，为什么直接给Form组件本身增加disabled属性会导致置灰不完全，比如input输入框？

这是因为antd的Form组件的disabled属性仅仅是将整个Form表单的字段都设置为disabled状态，它并不会作用到Form内部的子组件，比如input输入框。所以，直接给Form组件本身增加disabled属性会导致只有表单字段被禁用，而子组件不会受影响。

解决这个问题的方法是，在 Form 组件内通过 API 设置表单项的 `disabled` 属性，而不是直接在 Form 组件本身设置。比如可以使用 `Form.Item` 组件包装每个表单项，然后在 `Form.Item` 组件上设置 `disabled` 属性，这样就只禁用了单个表单项，而保持了其他表单项的正常状态。

#### 那你说一下Form 组件 fields 的值的传递原理？

在 Ant Design 中，`Form` 组件维护一个表单数据的内部状态form对象，并且会实时同步表单项的数据和这个内部状态。`Form` 中的 `fields` 属性可以用于指定表单项初始值和控制表单项的取值和赋值。

当表单数据发生变化时，`Form` 组件会自动更新表单项的值和表单数据的内部状态，并触发 `onValuesChange` 属性中指定的回调函数来处理新的表单数据。而当需要应用某个 `fields` 属性时，`Form` 组件会根据这个属性值来创建表单项的初始数据，并通过 `setFieldsValue` API 方法将这个初始值设置到表单项中。

当用户提交表单时，`Form` 组件会收集所有表单项的数据，并合并到表单数据的内部状态中，然后通过 `onFinish` 属性中指定的回调函数来处理表单数据的提交。

总的来说，`Form` 组件的 `fields` 属性是以内部状态和表单项之间双向数据绑定为原理进行数据传递的。通过这种方式，可以使表单数据的操作更加方便和高效。

通过 useForm 拿到 form 实例对象，设置到 Form 组件里，然后用 form.setFieldsValue 设置的字段值就能在 Form.Item 里取到。**原理**其实是使用了Context，有一个传递 form 对象的 context，Form 组件往其中设置值，Item 组件在根据name设置的路径去取其中的部分值。

#### context 的原理呢？

createCotnext 就是创建了一个 _currentValue、Provider、Consumer 的对象。

_currentValue 就是保存值的地方

Provider 是一种 jsx 类型，之后会转为对应的 fiber 类型，然后它的处理就是修改 _currentValue，也就是修改 context 值

Consumer 和 useCotnext 就是读取 _currentValue，也就是读取 context 值。

唯一要注意的是 Provider 处理每个节点之前会入栈 context，处理完会出栈，这样就能保证 context 只影响子组件。

[React Context 实现原理：它在 antd 源码里简直用的太多了 - 掘金](https://juejin.cn/post/7200002468460806205)

#### 简单介绍一下反作弊系统

这是一个给运营，产品使用的反作弊系统，我负责的模块的粉丝这块，主要是进行对不同用户的粉丝行为进行数据可视化的展示方便运营使用。

在这个项目由于存在大量图表，请求大量数据服务器压力大 **（背景）**，我在请求时机，和请求次数上做了适当的处理，切换组件时进行了缓存组件，首屏渲染时只进行基本的用户信息和粉丝行为图表的请求，其他详细的行为图表，都在拉动互动指标数据表区间，才进行请求  **（选择解决方法）**。

#### 那说一下你怎么解决后端压力的？

首次进入时，如果url上有查询信息，直接触发查询使用（useEffect监听，useSearchParams）来决定现在是否直接发起请求，以及查询请求只会触发基本不改动的信息，频繁改动的信息使用一个trigger变量控制。使用Antd的Tabs`destroyInactiveTabPane={false}`来缓存不同的图表组件。并且为了数据的方便使用和维护，都在整个模块index入口文件使用context向子组件传递属性和回调函数。

#### 使用自定义hooks，减少繁杂的echarts配置，描述一下你是怎么自定义hooks的？

自定义 Hooks 作用是可以将组件之间共享的逻辑抽离出来，使得组件更加纯粹，更具可读性和可维护性，提高代码的复用性。

由于图表大多数配置是默认不变的，主要改变的是`series`配置项里面的data因此我自定义的Hook，主要用于发送数据请求（在使用 `useEffect` 钩子监听 params 和 trigger 等传递的变量的变化，当 trigger 变量为 true 时，调用 run 方法发送数据请求）。根据请求结果，将每个数据项转化成 echarts 系列配置选项中的 data 属性，并按照数值大小排序。然后将数据进行加工排序，在合并默认设置的echarts 系列的 **seriesOptions** 配置选项返回出去。这样在请求数据时直接可以获得默认好的  **series配置项**  数据，并且配合封装的图表组件（已经设置看默认的baseOptions）实现控制数据推动图表展示改变，通过自定义 Hooks，我们可以将 Echarts 初始化和配置分离出来，让代码更加清晰易懂。

传入请求url，parmas -> 获得带有data数据的配置项，在配合好封装的线图，饼图等等，在不需要使用默认series配置项的时候就解构用data即可，需要使用时就直接使用默认series配置项。

#### 简单说一下你是怎么封装的通用图表组件？

对于不同的图表类型分别封装了通用饼图，曲线图。上面封装的hooks就是返回的 **series配置项，** 于是基本的图表组件就是封装的**基本配置项baseOptions。**

对于曲线图，由于业务需要展示不同时间量级的图表，封装组件我使用series配置项和x轴数据，默认选择项等等是外部动态传递来实现。 

#### 你对封装组件的理解？

封装组件是一种提高代码复用性，降低代码耦合度以及提高代码的可维护性的方式。将一些独立的、可复用的功能封装成一个组件，并暴露一些对外的接口，以供其他地方使用。具体来说，封装组件可以达到以下几个目的：

1. **复用性**：将一些相对独立的功能封装成一个组件，可以有效地提高这些功能的复用性，降低代码的重复度。

2. **封装参数**：通过参数传递的方式，可以在一个组件中封装不同的配置和数据，使得同一组件能够呈现出不同的功能和样式。

3. **解耦**：通过一个明确定义的接口，可以将组件与其他组件或业务逻辑代码解耦，使得修改组件不会影响其他代码的正常运行。

4. **易维护**：将各种功能进行封装，可以降低代码的复杂度，减少代码的冗余，提高代码的可维护性。

5. **易测试**：通过测试封装的组件可以有效地对组件的功能和 API 进行测试，减少代码测试的难度和成本。

在实际开发中，我们可以使用各种框架和库如 React、Vue 等进行组件的开发和封装，也可以根据具体的业务需求和开发语言进行选择。无论使用何种方式和工具，封装组件的目的都是为了提高代码的复用性、可维护性和可读性，使得开发更加高效、轻松和稳定。

#### Antd组件里面Tabs缓存组件的原理？

Antd 的 Tabs 组件里的 `destroyInactiveTabPane` 属性设置为 `false` 后，代表标签页无需每次切换时都重新渲染。此时，如果多次切换同一个标签页，前一次渲染出的组件不会被卸载，而是被缓存（保留 DOM 状态）。

底层实现原理是在 Tabs 组件中引入了 `rc-tabs` 基础包。在 `rc-tabs` 中，每次切换标签页后，会将要隐藏的标签页销毁（已完成 unmount），将要显示的标签页进行渲染和显示。

当 `destroyInactiveTabPane` 属性设置为 `false` 时，`rc-tabs` 会将将要隐藏的标签页进行卸载，而不是销毁，卸载后的标签页会被缓存。在下一次再次切换到该标签页时，会将卸载前的缓存重新挂载（remount）到 DOM Tree 中。

这种缓存组件的方式，可以提高标签页切换的性能，但是需要注意在卸载组件时，需要手动清理组件的定时器或绑定的事件等，否则可能会造成内存泄漏问题。同时也需要注意，如果缓存的组件本身拥有过多或占用过多内存，这种缓存方式可能会对网页性能造成不良影响。通常建议仅在组件轻量、易用、反复使用并且占用内存较小的情况下使用此项特性。

#### 说说对React中context的理解，有可替代方案（Dva等）吗？

React 中的 context 是一种跨组件层级传递数据的方式。它可以让父组件向子组件传递数据，而无需在每一个子组件中显式地通过 props 的形式传递数据。Context 可以被看作是组件树上的全局变量。

使用 Context 时，我们定义一个 Context 对象，可以通过 React.createContext 方法创建。Context 对象中包含两个组件：Provider 和 Consumer。Provider 用于设置 Context 的值，Consumer 用于获取 Context 的值。当 Context 值发生改变时，所有使用该 Context 的组件都会自动更新。

Dva 是一个类 Redux 的应用框架，提供了更多的约定和自动化的流程，以简化 Redux 的使用，并添加了一些额外的功能和插件。在 Dva 中，可以使用 Model 中的 state 来解决跨组件传递数据的问题，这类似于使用 Redux 中的 Store 来管理数据。在 Model 中保存的数据可以被整个应用中的组件共享和访问，而无需使用 Context 或 props 进行传递。

相较于使用 Context，Dva 可以更好地解决组件层级嵌套较深时，Context 数据传递行为变得复杂难以理解的问题。但 Context 也有自己的优点，例如，它可以更加灵活地传递数据；它是 React 自带的 API，无需引入额外的依赖，并且可以与 React 官方的工具协同工作。

因此，在实际使用中，我们需要根据具体场景来选择合适的数据传递方案。在数据传递行为简单的场景下，Context 能够带来极大的便利；而在数据传递行为复杂且需要更完整状态管理的场景下，Dva 的使用可能更适合。

#### Echarts了解到什么程度，底层是用canvas和re-render

#### 说一下实习的代码规范，现在接手项目的分支管理规范是怎样的?？

#### chrome中怎么调试 => f12\devtools插件

#### 项目里的登录功能是怎么实现的？项目里关于权限控制这块怎么做的？有了解哪些权限控制的方式？或者说更优雅地进行权限控制？

#### 说一下你对业务的理解

#### 实习公司的业务领域和产品是什么？你在其中扮演的角色是什么？

公司的业务主要是toB的，主要的产品使用对象是运营和产品，对内有管理员工，对外有知乎线上内容数据审核，处理等等。我扮演前端开发的角色，主要根据产品提出的rfc文档要求，和后端一起协商之后进行适当的计划与评估，出色的完成任务。

#### 你在实习期间遇到的最大挑战是什么？你是如何解决的？

技术上：挑选上面项目难点，比如表单封装，hooks自定义。

业务上：多和产品，后端进行细致的沟通，很多时候好的沟通往往就是高效工作的保障。然后举例，比如和后端沟通接口返回的数据格式，直接根据后端返回的数据一步渲染表头，表体。和产品适当勇敢提出业务需求的不合理或者建议。

#### 你在实习期间完成了哪些具体的项目或任务？你在其中负责的部分是什么？你的成果和贡献是什么？

一个人独立的完成了产品交付的较大需求模块，主要负责绩效模块，反作弊模块粉丝分析，主要成果封装了通用的组件，和自定义hooks复用，大大提高了开发效率。

#### 你在实习期间使用了哪些前端技术和工具？你是如何学习和使用它们的？你的技能水平如何？

学习了基本的联调，测试，部署流程。以及基本的git协作。

#### 你对前端技术或者前端行业的发展有什么看法或者想法？你是否有在业余时间学习或者研究前端相关内容？

前端现在发展十分迅猛，各大框架，低代码满天飞，在关注技术爆炸的同时不能浮与表面，然后说自己平时经常看书，写博客，举出自己看了axios源码，一些react原理什么的。

#### 遇到的最大困难,沟通上遇到过那些问题，前端后端的接口文档是你在负责吗？你对这种前后端对接的工作有什么心得吗？

#### 项目里面为什么使用axios能说说吗？用axios做了哪些事情？，拦截器的执行顺序？

Axios 是一个流行的基于 Promise 的 HTTP 库，它可以在浏览器端和 Node.js 中发送 HTTP 请求。使用 Axios 的优点有：

1. 支持浏览器和 Node.js。Axios API 支持浏览器和 Node.js，因此可以在前后端分离的项目中一致地发送 HTTP 请求，并且不需要多种不同的库。

2. 支持 Promise。Axios 的 API 基于 Promise，使得我们能够使用 Promise 的特性，例如 async/await。

3. 更友好的 API。相对于其他的 HTTP 库，Axios 的 API 更加容易使用和理解，例如设置拦截器、设置请求和响应拦截器等。

4. 功能更强大。Axios 提供了许多可定制的选项和功能，例如设置请求和响应的拦截器、支持文件的上传和下载、支持取消请求、xsrf 防御等，这些功能可以帮助我们更好地控制 HTTP 请求。

综上所述，使用 Axios 可以带来更好的 API 设计，更高效的性能表现，更好的扩展性以及更丰富的特性和选项，这些都使得它成为前后端分离项目中的理想选择。因此，在项目中选择使用 Axios 是一个合理的选择。

#### 能说说axios具体是怎么封装的吗？项目里怎么封装请求的?

当我们使用 Axios 发送一个请求时，我们需要配置请求的方法（GET、POST 等）、地址、请求头、请求数据等，这些配置都是通过 Axios 提供的 API 来完成的。在实际项目中，我们可能需要对 Axios 进行一些定制和封装，例如添加请求和响应的拦截器、封装通用的请求和错误处理、设置 baseURL 等。

在项目中，我们使用 `axios.create` 方法创建了一个 Axios 实例 `instance`，并设置了公共的 `baseURL` 地址和请求超时时间。接着，我使用 `instance.interceptors.request` 和 `instance.interceptors.response` 添加了请求和响应的拦截器，以便添加或处理请求头、响应数据以及通用的错误处理，将请求错误的状态码，请求超时等等信息打印出来。最后，我通过封装通用的 `get` 和 `post` 方法来简化发送请求的过程。

#### 用过fetch吗?fetch和axios的区别知道吗?

**1、最大的不同:**

**最大的不同点在于Fetch是浏览器原生支持，而Axios需要引入Axios库。**

**2、兼容性方面**

Axios可以兼容IE浏览器，而**Fetch在IE浏览器和一些老版本浏览器上没有受到支持**，但是有一个库可以让老版本浏览器支持Fetch即它就是whatwg-fetch，它可以让你在老版本的浏览器中也可以使用Fetch，并且现在很多网站的开发都为了减少成本而选择不再兼容IE浏览器。

**3、响应超时**

Axios的相应超时设置是非常简单的，直接设置timeout属性就可以了，而Fetch设置起来就远比Axios麻烦，这也是很多人更喜欢Axios而不太喜欢Fetch的原因之一。

**4、对数据的转换**

Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168028911-84fe2da0-bfe4-4130-8ee4-0e8309c630de.png)

5、拦截器

Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到。

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168069438-bbc3cedc-e011-4734-a896-f14ac5a1ae78.png)

最后附带上一些想法:

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168120392-7de5cdbe-ec8b-4184-a58b-2beb97c8bb91.png)

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1647168149928-58f3b73d-72ec-48b5-8e09-6a6030b33806.png)

#### 开发调试用过什么？移动端做过什么？怎么调试？

在前端开发中，我主要用过以下工具和方法来进行调试：

1. 浏览器开发者工具：浏览器开发者工具中提供了丰富的调试工具，比如 Console、Elements、Network、Sources 等面板。我们可以利用这些工具来查看页面结构、监控网络请求、调试 JavaScript 代码、修改样式等等。

2. VS Code 调试工具：VS Code 提供了非常强大的调试工具，可以用来调试 Node.js 应用、前端应用等等。我们可以通过配置调试选项，打断点、单步调试等等，来进行精确的调试。

3. Charles Proxy：Charles Proxy 是一款用于调试网络请求的工具，可以使用它来监控整个应用的网络请求，并且可以对请求和响应进行修改和复制等等操作。

4. 调试工具插件：比如 Redux DevTools、React Developer Tools 等，这些插件可以帮助我们调试某些特定的技术栈和工具。

总的来说，调试的主要流程可以分为以下几个步骤：

1. 定位问题：首先需要定位问题所在，查找报错信息、打印日志等等。

2. 复现问题：尽可能地复现问题，找到复现问题的具体步骤和条件。

3. 分析问题：通过调试工具和方法，对问题进行分析和定位，找出原因。

4. 解决问题：根据问题的具体原因，采取相应的解决方案来修复或优化代码。

在调试过程中，我们需要有耐心和细心，并且要尽可能地利用现有的工具和方法来提高调试效率和精度。

#### 性能优化过程和具体方法，如何监控性能指标，做性能优化的思路和过程，首屏渲染时间怎么看的？指标是啥？0.9s这个时间怎么看的？指标是啥？了解过有哪些与性能优化相关的工具吗？

首先我会使用使用 Chrome 开发者工具中的 Performance 和 Network 面板进行监控和分析，找出性能瓶颈，进行相应的优化。然后考虑大家使用的常规的优化手段，例如减少请求次数（使用路由缓存），减少重拍重绘（使用css动画，betterScorll滚动）等等。

在首屏渲染等等查看上我先是使用的浏览器自带的调试面版，以及`Performance-Analyser`，然后我自己还根据Performance API 写了一个各项性能指标计算的工具函数。

#### 你是怎么实现这个各项性能指标计算的工具函数的？

performance的API是浏览器暴露给js的一个接口，可以通过这个接口查看用户访问网站的连接建立时间、dns时间等信息。使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。于是我通过onload事件绑定了一个回调函数，根据 performance.timing的相关属性进行计算得到首屏渲染，重定向，DNS解析等等各项数据。其中白屏时间我主要是根据`time.domLoading - time.fetchStart`计算得来的。其他的大多也就是网上查询计算公式的得到的。

[性能优化——window.performance监测载入白屏时间 - 掘金](https://juejin.cn/post/7054521713748344869)

#### 项目里路由懒加载如何实现的？原理是什么？还有其他的方法吗？

为什么要使用路由懒加载?

当刚运行项目的时候，发现刚进入页面，就将所有的js文件和css文件加载了进来，这一进程十分的消耗时间。 如果打开哪个页面就对应的加载响应页面的js文件和css文件，那么页面加载速度会大大提升。

路由懒加载一定会提高页面加载速度吗，什么时候用路由懒加载

**懒加载的好处是什么?**

懒加载简单来说就是webpack将代码拆分为多个bundle，同时可以按需或者并行加载。因此，为了提高应用的性能，即在需要的时候的时候进行加载。我们可以尝试如何合理的分割代码并延迟加载。

**怎么使用的路由懒加载?**

使用到的是es6的import语法，可以实现动态导入

```
const Search = lazy(() => import("./../application/Search"));

const SuspenseComponent = Component => props => {
    return (
        <Suspense fallback={<Skeleton />}>
            <Component {...props}></Component>
        </Suspense>
    )
}

{
    path: '/search',
    exact: true,
    component: SuspenseComponent(Search),
}
```

![](https://cdn.nlark.com/yuque/0/2022/png/23076793/1646967987267-e6df2d9c-db4f-42da-ba3d-280af9a312e3.png)

**路由懒加载的原理是什么?**

webpack在编译时，识别到动态加载的import语法，则webpack会为当前动态加载的模块创建一个单独的bundle。如果你使用的是官方的Create-react-app脚手架或React的服务端渲染框架Next.js，那么可以直接使用动态import语法。如果你的脚手架是你自己配置的webpack，那么你需要按照官方指南来设置。

通过Webpack编译打包后，会把每个路由组件的代码分割成一一个js文件，初始化时不会加载这些js文件，只当激活路由组件才会去加载对应的js文件。

懒加载之后只有在激活的时候才会被加载吗？

作用就是webpack在打包的时候，对异步引入的库代码进行代码分割时（需要配置webpack的SplitChunkPlugin插件），为分割后的代码块取得名字

React中运用import的懒加载语句以及webpack的魔法注释，在项目进行webpack打包的时候，对不同模块进行代码分割，在首屏加载时，用到哪个模块再加载哪个模块，实现懒加载进行页面的优化。

[基于React.Suspense和React.lazy的前端性能优化 - 掘金]()

#### 项目里是怎么做打包的？,有对打包做过哪有优化？前端页面优化

答: 从请求和运行两方面考虑。
请求:压缩图片（埋下伏笔QAQ）、压缩代码、开启gzip/compress、懒加载、cdn、雪碧图、本地缓存...
运行:优化用户体验。减少重排、滚动优化、骨架屏、防抖节流...
用到的性能优化办法

#### 说说你对防抖节流的理解吧?，以及项目里面的应用？节流用在什么地方，自己的项目中用到了吗？如何实现？如何优化？

我在用户上拉下拉滚动页面的时候给回调函数添加了防抖的处理，防止频繁触发重复的请求，我也在搜索框的地方使用了防抖处理，将外部传入的搜索查询函数在组件内部进行防抖处理。

**防抖函数的应用场景：**

- 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
- 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce

**节流函数的适⽤场景：**

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
- 缩放场景：监控浏览器resize
- 动画场景：避免短时间内多次触发动画引起性能问题

#### 你在项目中遇到过哪些困难和挑战？你是如何解决的？你对项目中某个具体功能或者模块的实现过程有没有什么特别的见解或者想法？哪个项目是从头自己搭建的，整体搭建思路、流程、为什么选取这个技术栈,介绍一下项目，并说一下你认为最有成就感的一个点。

#### xxx组件你是怎么实现的？

#### 口撕虚拟列表 用的第三方库还是自己实现，第三方库实现和自己实现有区别吗（待补充）

自己实现的，配合betterScorll的实例对象，进行`scorll`事件监听进行处理。根据滚动计算出新的end下标,增加渲染列表长度。

#### 什么是 RTK？RTK 框架中有哪些 API？React 是如何使用 Redux Toolkit 的？RTK 中 `createSlice` 方法有哪些参数？如何使用 RTK 处理异步请求？RTK 的实现原理是什么？RTK 和 Redux 的对比？

# 在线教育项目

## 为什么选择`Sequelize`？不选择其他的ORM框架？

- 基于 promise 的 Node.js 的 ORM
- 支持多种数据库
- 具有强大的事务支持，关联关系，预读和延迟加载等功能
- 官网：[https://www.sequelize.com.cn](https://www.sequelize.com.cn)

sequelize 支持数据库多样，而且具有强大的事务支持，关联关系，预读和延迟加载等功能。比如添加一条评论，在评论总数也要+1，这2件事要么同时成功要么同时失败，这就保证了数据不会失败。 

#### seo优化有哪些？你使用了哪些？提高网站的SEO有哪些方法？单页面项目为什么不能真正实现SEO优化？

SEO搜索引擎优化

- 利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，吸引更多的用户访问网站，提高网站的访问量，提高网站的销售能力和宣传能力，从而提升网站的品牌效应

- 搜索引擎优化的技术手段
  
  - 黑帽SEO
    
    - 通过欺骗技术和滥用搜索算法来推销毫不相关、主要以商业为着眼的网页，导致用户搜索到不满意的搜索结果（遭剔除）
    
    - 主要手段
      
      - 关键字的堆叠
      
      - 隐藏文本（热门的关键词在网站上小字体展示，或者隐藏，但是这些关键词与该网站不相关）
      
      - 门页（适黄网、小游戏广告）
  
  - 白帽SEO
    
    - 为用户创造内容、让这些内容易于被搜索引擎机器人索引、并且不会对搜寻引擎系统耍花招
    - 优化需要较长时间，不断更新网站的内容和外链
    - 用户更加友好，从这些网站中获得更合理的流量
    - 主要特点是见效慢、稳定性强、可长期发展

- TDK
  
  - 设置网站的 title 标题标签，如：
    
    <title>小滴课堂</title>
  
  - 设置网站的 description 描述标签，如：
    
    <meta name="Description" content="小滴课堂是IT技能学习平台,提供了丰富的java开发、web前端" />
    
    <meta name="Description" content="小滴课堂是IT技能学习平台,提供了丰富的java开发、web前端" />
  
  - 设置网站的 keywords 关键词标签，如：
    
    <meta name="keywords" content="小滴课堂,小D课堂,xdclass,java,vue教程,html教程,js教程,w3c教程,css,webpack">
    
    <meta name="keywords" content="小滴课堂,小D课堂,xdclass,java,vue教程,html教程,js教程,w3c教程,css,webpack">
    
    <meta name="keywords" content="小滴课堂,小D课堂,xdclass,java,vue教程,html教程,js教程,w3c教程,css,webpack">

- 提高网站语义化的html标签占比
  
  - 增强了可读性，结构更加清晰，便于对浏览器、搜索引擎解析
  
  - 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO
  
  - a、p、ul、ol、li、h1、h2、h3...

- SSR
  
  - 服务端渲染，服务端生成html返回给浏览器渲染，页面的数据可以更好的给搜索引擎收录到

    #### 单页面项目为什么不能真正实现SEO优化？

- 通过查看源代码我们发现，源代码并没有显示我们页面中实际渲染的内容，这种由浏览器端的js做主导渲染网页内容的方式，我们就称之为客户端渲染

- 在客户端生成html，搜索引擎不会等待异步请求到数据返回给到前端页面时再爬取

- SPA项目里面，几乎都是使用 AJAX 获取后端的数据，就会导致我们的页面数据不能被搜索引擎正常收录到

- 强交互、不注重SEO的页面，例如：管理、组件库类的项目

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-14-32-21-image.png)

服务端渲染（SSR）

- 由服务端生成html下发到浏览器直接渲染

- 搜索引擎抓取我们页面内容的时就已经能获取到html里面的内容了，所以就有更高的搜索权重，利于SEO

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-14-33-34-image.png)

服务端渲染需要考虑的点：

- 不像客户端渲染的SPA部署在阿里云静态文件服务器上就能访问，需要有服务器运行node的环境
- 更高的服务器负载，因此服务器的配置要准备好，以及合理的缓存策略

#### 分布式缓存Redis是什么？

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-14-37-25-image.png)

什么是Redis

- 属于NoSQL的一种 ( Not Only SQL )
  
  - 是不同于传统的关系数据库的数据库管理系统的统称
  - 其两者最重要的区别是NoSQL不使用SQL作为查询语言。
  - NoSQL数据存储可以不需要固定的表格模式
  - 键 - 值对存储，列存储，文档存储，图形数据库
  - NoSql：redis、memcached、mongodb、Hbase

- 官网地址：[https://redis.io/](https://redis.io/) 中文：[http://www.redis.cn/](http://www.redis.cn/)

- 高性能：Redis能读的速度是110000次/s,写的速度是81000次/s

- 内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如字符串（strings）、散列（hashes）、 列表（lists）、 集合（sets）、 有序集合（sorted sets）等

#### 你在项目中哪些地方使用到了Redis？

弹幕功能 + 验证码获取

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-14-51-47-image.png)

#### 从0认识Node之ORM框架

- 怎么理解ORM框架
  
  - Object Relational Mapping 对象-关系-映射
  
  - ORM框架就是将关系型数据库映射成面向对象模型，方便我们以操作对象的方式操作数据库
    
    ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-14-58-23-image.png)

- 特点：
  
  - ORM框架的内部逻辑会实现 sql 防注入，对数据库操作只需调用框架提供的对应 api 即可，不需要担心原生 sql 的问题
  
  - 提高开发效率，不用写繁琐重复的sql语句
  
  - 调试 sql 会比较麻烦，但是很多框架都支持写原生 sql
  
  - 复杂的 sql 语句，很难通过框架语法写出来，故可以用原生 sql
    
    ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-15-03-51-image.png)
    
    Sequelize
    
    - 基于 promise 的 Node.js 的 ORM
    - 支持多种数据库
    - 具有强大的事务支持，关联关系，预读和延迟加载等功能
    - 官网：[https://www.sequelize.com.cn](https://www.sequelize.com.cn) 

为什么选择Sequelize？

- 当前node项目是单纯使用js开发
- 基于 promise 的 Node.js 的 ORM，目前支持 Mysql等多种数据库
- 具有强大的事务支持
- ORM框架满足我们基本的增删改，以及简单的关联查询，涉及较复杂的多表关联查询大部分还是用SQL

`Sequelize` 基本配置

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-15-12-02-image.png)

#### 定义数据表模型同步和初试操作，提高模型同步的开发效率-sequelize-auto，Promise异步实现数据库增和查操作，Promise异步实现数据库改和删操作（略）

### `Sequelize`基本使用

这段代码使用了 Sequelize 库来连接数据库，并测试连接是否成功。

首先，我们通过 `require` 引入了 Sequelize 库。然后，创建了一个 Sequelize 实例 `sequelize`，并传入了数据库名、用户名、密码和连接参数等信息。其中，`host` 参数指定了数据库服务器的公网 IP 地址，`dialect` 参数指定了使用的数据库类型。在这个例子中，我们使用的是 MySQL 数据库。根据实际需要，您需要根据自己的环境配置这些参数。

接下来，我们使用了一个自执行函数，该函数将尝试使用 `await sequelize.authenticate()` 进行数据库连接测试。如果连接成功，则打印 "数据库链接成功" 的消息；否则，将打印 "数据库链接失败" 的消息，并输出具体错误信息。

需要注意的是，这里使用的是异步函数 `async function()` 和 `await` 关键字来处理异步操作，这使得我们可以避免回调嵌套和使用 Promise 的复杂性，使代码更加简洁易懂。

通常，在这段代码的基础上，我们可以继续编写数据模型定义、数据操作等相关业务代码来完成对数据库的访问和操作。

#### Sequelize实现一对一关系表关联和查询（！）

原生左链接

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-15-52-10-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-15-52-47-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-15-57-37-image.png)

#### 一对多关系表关联和查询（略）

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-05-27-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-07-16-image.png)

#### Mysql事务介绍和使用，  Mysql常见的存储引擎你知道多少？

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-09-03-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-11-53-image.png)

#### mysql数据库的InnoDB和MyISAM储存的区别？

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-16-34-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-18-31-image.png)

#### 剖析小滴云项目架构和数据库设计

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-23-48-image.png)

#### 你是如何根据小滴云PC端业务需求设计数据库？

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-16-32-04-image.png)

#### TypeScript快速入门接口和范形？（略）

**创建初始的本地服务器+接口请求中间件配置**

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-02-33-image.png)

 错误中间件在中间![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-05-25-image.png)

#### 你知道哪些设计模式？你在项目中使用到了哪些设计模式？

解耦

- 在程序中依赖的第三方插件、应用，尽量通过自定义二次封装到到工具类中，使用时程序只需要依赖唯一的类，而避免第三方插件不支持导致项目程序牵一发而动全身
  
  ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-09-19-image.png)
  
  生活中的例子：
  
    老王在广州有好几栋房子位于城中村，出租的房子几乎有上百间，此时老王需要对接这上个百个租户，-对多个租户，每天忙得焦头烂额，一旦老王发生意外，事情就变得麻烦了。
  
  如果对老王与租户进行解耦，找了中介，那么老王只需要对接中介，一对一就可以
  
  封装解耦涉及的设计模式-中介者模式
  
  - 利用中介对象来封装一系列的对象交互，程序使引用第三方插件不需要显示地相互引用，从而使其耦合松散
  - 优点：项目程序中提高公共引入的复用，以及在维护和迭代程序时更加容易

- 提炼自己项目中的设计模式
  
  - 不同的场景，角度下可能会有多个设计模式，并不是固定、统一的
  
  - 面试中经常会被问到的高频面试题，在于平时开发、学习的积累
  
  - 其他的设计模式
    
    - 代理模式
    - 门面模式
    - 装饰器模式
    - 工厂模式

项目封装了使用了md5（不可逆），jwt加密（可逆）

#### 获取token登录，使用express-jwt判断，排除不需要token就可以的，放在接口的最上方

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-27-23-image.png)

这段代码使用了`express-jwt`中间件来进行身份验证和授权处理。下面是对代码的解释：

```js
const { expressjwt: jwt } = require('express-jwt');
app.use(jwt({ secret: jwtSecretKey, algorithms: ['HS256'] }).unless(
  {
    path: [
      /^\/api\/user\/v1\/register/,           //注册
      /^\/api\/user\/v1\/login/,              //登录
    ],
  })
);
```

1. 首先，通过`require('express-jwt')`引入了`express-jwt`模块，并使用对象解构赋值将其命名为`jwt`。

2. 然后，调用`app.use()`函数，将身份验证中间件应用到 Express 应用程序中。

3. 在中间件的参数中，使用`jwt()`函数创建了一个身份验证中间件。它接受一个包含选项的对象作为参数。

4. 在选项对象中，`secret`字段指定了用于验证 JSON Web Token (JWT) 的密钥，而`algorithms`字段指定了支持的签名算法（此处为HS256）。

5. 使用`.unless()`方法设置了例外规则，即以下路径不需要进行身份验证。在这个例子中，只有`/api/user/v1/register`和`/api/user/v1/login`请求不需要验证，其他请求都需要进行身份验证。

总之，这段代码的作用是通过`express-jwt`中间件对请求进行身份验证，要求除了注册和登录接口以外的所有请求都需要提供有效的 JWT。

除了使用回调函数，还有其他方法可以确保状态更新完毕后再执行后续代码。

#### Redis相关

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-40-49-image.png)

#### redis常见数据结构有哪些？

**Redis7数据结构之String类型介绍+核心命令**

- 数据结构介绍：

- 应用场景：验证码、计数器、订单重复提交、用户登录信息、商品详情

- 核心命令： set/get/increment/decrement/del
  
  ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-43-06-image.png)

**Redis7数据结构之List类型介绍+核心指令**

- 应用场景：简单队列、最新商品列表、评论列表

- List核心命令
  
  ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-44-11-image.png)
  
  **Redis7数据结构之SortedSet类型介绍+核心命令**
  
  - 应用场景：商品日销榜、积分榜等
  
  - SortedSet核心命令
    
    ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-17-44-37-image.png)

一种方法是使用 `useEffect` 钩子监听状态的变化，并在状态更新后执行相应的代码。下面是一个示例：

```jsx
useEffect(() => {
  handleRequest();
}, [searchParams]);

const onPageChange = async (page: any) => {
  setSearchParams({ ...searchParams, page });
  await setEditingKey("");
};
```

在上述代码中，我们使用了 `useEffect` 钩子来监听 `searchParams` 的变化。一旦 `searchParams` 发生变化，`handleRequest` 将会被执行。

另外，为了避免重复执行 `handleRequest`，将 `searchParams` 添加为 `useEffect` 的依赖项。这样，只有当 `searchParams` 发生变化时才会触发 `handleRequest`。

通过这种方式，无论是在 `onPageChange` 中调用 `setSearchParams` 还是在其他地方更新 `searchParams`，只要 `searchParams` 发生变化，`handleRequest` 就会被正确地执行。

请注意，在使用 `useEffect` 时，确保将其放置在组件的函数体内，并遵循 React Hook 的规则。

如果 `searchParams` 是一个对象，并且你希望在它发生变化时执行某些操作，你可以使用 `useEffect` 钩子，并使用深层比较（deep comparison）来检测对象的变化。这样，只有在对象的某个属性发生实际变化时，才会触发回调函数。

以下是一个示例代码：

```jsx
useEffect(() => {
  handleRequest();
}, [JSON.stringify(searchParams)]);

const onPageChange = async (page: any) => {
  setSearchParams({ ...searchParams, page });
  await setEditingKey("");
};
```

在上述代码中，我们使用 `JSON.stringify` 将 `searchParams` 对象转换为 JSON 字符串，并将其作为依赖项传递给 `useEffect`。这样，在每次渲染时，React 将比较新的 JSON 字符串与前一个字符串，以确认是否发生了实际的变化。

请注意，使用深层比较可能会对性能产生一定的影响，特别是当 `searchParams` 对象较大或发生频繁的变化时。如果你的对象非常复杂，你可能需要考虑使用更高级的比较方法，例如自定义的比较函数或第三方库。

另外，确保将 `useEffect` 放置在组件的函数体内，并遵循 React Hook 的规则。

## 微信登录实现

- 社交登录
  
  - 含义：访问某个网站的用户可以通过社交媒体账号登录
  
  - 优点
    
    - 可以利用社会化媒体的影响增加网站和用户粘性，提高留存
    - 借助分享、裂变等方式对网站进行推广，提高知名度 AARRR中的留存和传播
    - 同时增加网站的流量，使用量，提高网站产品的转换率
  
  - 类型
    
    - 腾信微信
    - 腾讯QQ
    - 阿里支付宝
    - 微博
    - .....
    
    微信登录分为
    
    - 场景二维码登录
    - Oauth2.0授权登录

##### 生成二维码阶段

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-21-33-10-image.png)

总体步骤：

1. 微信授权给服务器

2. 服务器调用wx接口拿到ticket，反回前端二维码，将ticket存储在redis （isScan：true 判断是否扫码）

3. 前端扫码，wx调用服务器接口发送ticket和openid 

4. 服务器查询数据库判断用户是否组册过，生成对应token

5. 服务器查询redis中isScan 是否为true 是就返回前端isScan + token

##### 具体详细步骤

1. 微信授权

获取到开发者的id + secret + 自己node服务器提供的接口，token

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdccc6057041487d98873527cd0e46f2~tplv-k3u1fbpfcp-watermark.image?)

**从微信服务器接入中看数据安全传输的难点-密码学对称加密**

- 对称加密
  
  - 发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算
  - 使用对称加密，必须保证秘钥和加密方式的安全，否则数据将会有泄漏的风险，而非对称加密就没有这问题，微信支付时会讲到

- 微信服务器接入为什么要做对称加密呢？
  
  - 保证我们服务的安全，除了微信服务器，其他方式调用我们接口都是不允许的

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-18-24-52-image.png)

JWT生成token的对称加密

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-18-26-10-image.png)

#### 详解第三方微信登录场景二维码方式接口开发

1. **微信服务器回调本地接口接入验证**

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-26-23-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-29-23-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-29-35-image.png)

2. **深入理解封装获取微信场景二维码配置开发**
- 创建获取二维码接口
  
  http://127.0.0.1:8081/api/wx_login/v1/login
  
  1. 请求微信服务器获取 access_token
  
  2. 根据access_token请求微信服务器获取 ticket
  
  3. 根据ticket返回二维码
     
     ```js
     const axios = require("axios");
     
     const appId = 'Ek7blIsBmbSfMjjUjK'
     const appSecret = 'Vwqd07rdbhCSpc6DfGZjyy1zCkfhJnYE'
     const accessTokenPC = `https://api-v2.xdclass.net/cgi-bin/token?grant_type=client_credential&appid=${appId}&secret=${appSecret}`
     const qrUrl = 'https://mp.weixin.qq.com/cgi-bin/showqrcode'
     
     // 获取微信access_token
     const getAccessToken = () => {
         return axios({
             method: 'get',
             url: accessTokenPC
         })
     }
     
     // 获取拼接微信二维码url的ticket
     const getTicket = (token) => {
         return axios({
             method: 'post',
             url: `https://api-v2.xdclass.net/cgi-bin/qrcode/create?access_token=${token}`,
             data: {
                 expire_seconds: 60 * 2,
                 action_name: "QR_SCENE",
                 action_info: {
                     "scene": { "scene_id": 123 }
                 }
             }
         })
     }
     
     // 获取微信二维码url
     const wechatLogin = {
         getOR: async () => {
             let token = (await getAccessToken()).data.access_token
             let ticket = (await getTicket(token)).data.ticket
             return { qrcodeUrl: `${qrUrl}?ticket=${ticket}`, ticket: ticket }
         }
     }
     
     module.exports = wechatLogin
     ```
  
  ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-35-01-image.png)
  
  ![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-35-10-image.png)
  
  3.**掌握流数据+xml数据处理接受微信服务器请求参数**
  
  将xml 转化为obj 遍历obj 为最新对象
  
  ```js
  /**
   * @param {*} getXMLStr 以流的形式接收微信服务器发过来的数据
   * @param {*} getJsData 通过工具解析xml数据转换成对象
   * @param {*} getObjData 优化数据
   */
  var { parseString } = require('xml2js');
  
  // 微信XML数据类型处理
  class WxDataTool {
    static getXMLStr(req) {
      return new Promise((resolve, reject) => {
        let data = '';
        req.on('data', (msg) => {
          data += msg.toString();
        });
        req.on('end', () => {
          resolve(data);
        });
      });
    }
  
    static getJsData(data) {
      return new Promise((resolve, reject) => {
        parseString(data, (err, result) => {
          if (err) {
            reject('error');
          } else {
            resolve(result);
          }
        });
      });
    }
  
    static getObjData(obj) {
      let tempObj = {};
      if (obj && typeof obj === 'object') {
        // 循环对象，提取数据
        for (let key in obj) {
          let value = obj[key];
          if (value && value.length > 0) {
            tempObj[key] = value[0];
          }
        }
        return tempObj;
      } else {
        return tempObj;
      }
    }
  };
  
  module.exports = WxDataTool
  ```
4. **根据微信回调参数生成权限token+redis缓存状态+xml数据返回**
   
   根据openid判断是否组册过
   
   没有注册就数据库创建一条
   
   注册过就将查到的user的信息加密进入token
   
   更新redis数据库里面的 ticket的isScan植为true
   
   返回服务器的内容
   
   ```js
       wechat_message: async (req) => {
           // let xmlData = await WxDataTool.getXMLStr(req)
           let xmlData = Object.keys(req.body)[0]
           let objectData = await WxDataTool.getObject(xmlData)
           let lastData = WxDataTool.getLastData(objectData.xml)
   
           // 根据openid判断是否注册过
           let openidRes = DB.Account.findAll({ where: { openid: lastData.FromUserName }, raw: true });
           //随机生成用户的头像和昵称
           let head_img = RandomTool.randomAvatar()
           let username = RandomTool.randomName()
           let user = null;
           // 未注册则插入数据
           if (openidRes.length === 0) {
               let resData = await DB.Account.create({ head_img, username, id: lastData.FromUserName })
               user = { head_img, username, id: resData.toJSON().id }
           } else {
               // 注册过
               user = { head_img: openidRes[0].head_img, username: openidRes[0].username, id: openidRes[0].id }
           }
           // 生成token
           let token = SecretTool.jwtSign(user, '168h')
           // 更新redis状态 
           let key = `wechat:ticket:${lastData.Ticket}`
           const existsKey = redisConfig.exists(key);
           if (existsKey) {
               redisConfig.set(key, JSON.stringify({ isScan: 'yes', token }), 120)
           }
           // 返回微信服务器的内容
           let content = ''
           if (lastData.MsgType == 'event') {
               if (lastData.Event = 'SCAN') {
                   content = '欢迎回来'
               } else if (lastData.Event = 'subscribe') {
                   content = '感谢关注'
               }
   
               let msgStr = `<xml>
                 <ToUserName><![CDATA[${lastData.FromUserName}]]></ToUserName>
                 <FromUserName><![CDATA[${lastData.ToUserName}]]></FromUserName>
                 <CreateTime>${Date.now()}</CreateTime>
                 <MsgType><![CDATA[text]]></MsgType>
                 <Content><![CDATA[${content}]]></Content>
                </xml>`
               return msgStr
           }
       },
   ```

5. **客户端怎么知道用户何时扫码？开发轮询接口**
   
   ```js
       check_scan: async (req) => {
           let { ticket } = req.query;
           let key = `wechat:ticket:${ticket}`
           let redisData = JSON.parse(await redisConfig.get(key))
           if (redisData && redisData.isScan === 'yes') {
               let { token } = redisData
               return BackCode.buildSuccessAndData({ data: `Bearer ${token}` })
           } else {
               return BackCode.buildResult(CodeEnum.WECHAT_WAIT_SCAN)
           }
   
       }
   ```

6. 前端轮训
   
   ```js
     let lock = true; // 防抖
     let timer: NodeJS.Timer | null = null;
     const [url, setUrl] = useState("");
     // 二维码地址接口请求
     const getQrcode = async () => {
       if (lock) {
         lock = false;
         const res: any = await getWechat();
         if (res.code === 0) {
           setUrl(res.data.qrcodeUrl);
           timer = setInterval(() => watchScanDate(res.data.ticket), 3000);
           lock = true;
         }
       }
     };
   
     useEffect(() => {
       getQrcode();
       // 如果关闭二维码组件，清除定时器
       return () => {
         clearInterval(timer as NodeJS.Timer);
       };
       // eslint-disable-next-line react-hooks/exhaustive-deps
     }, []);
   
     // 轮询请求接口查询用户扫码状态
     const watchScanDate = async (ticket: string) => {
       const res: any = await watchScan(ticket);
       if (res?.code === 0) {
         dispatch(changeToWechat(true));
         dispatch(changeToBase(false));
         clearInterval(timer as NodeJS.Timer);
         message.success("登录成功");
       }
     };
   ```

##### 开发的图形验证码解决了什么问题？为了什么类型的安全性而使用验证码呢？

为什么要使用图形、滑块等验证码校验

- 随机生成四位或者其他位数的图形文本，人为才能轻松识别，机器程序识别比较困难，增加了恶意的人为或机器程序的攻击
- 防止程序被恶意大量高频的调用，给我们服务造成很多无效的注册或登录，占用自身服务器的内存资源

##### 图形验证码一定安全吗？

- 图形验证码一定安全吗？
  
  - 攻击与防御是一直都存在的，滑动验证码和图形验证码也都是可以被破解的（ocr），ip也是可以租用。
  - 增加攻击者的成本，降低被攻击的风险

##### 什么是短信盗刷，怎么防止？如何避免自己的网站成为“肉鸡”？

- 如何避免自己的网站成为“肉鸡”？
  
  - 增加图形验证码
  - 限制一个ip的获取验证码的次数
  - 限制号码发送，设置每个月每个号码可以发送多少条短信，降低短信套餐成本。

### 图形验证码

##### 如何区分不同用户的图形验证码？

定义获取用户设备和ip标识，使用md5加密，作为redis的key值的一部分，用来区分

##### 区分不同的场景下的图形验证码？

注册时获取的验证码只能用于注册，不能使用登录。使用一个`type`字段作为`key`值的一部分，用来区分。

##### 细节

使用svg-captcha 要设置返回的格式

- let captcha = svgCaptcha.create({
  
    size: 4, // 验证码长度
  
    ignoreChars: '0o1i', // 验证码字符中排除 0o1i
  
    noise: 1, //干扰线
  
    background: '#aaa' // 背景颜色
  
  })

- 以图片格式返回
  
  res.set('content-type', 'image/svg+xml')
  
  并且要redis存储captcha.text

并且封装一个用户唯一标识作为redis的key（md5加密ip 和useragent)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-18-44-26-image.png)

### 短信验证码

#### 短信验证码平台选择考虑点

- 各个类型短信价格
- 短信到达率、到达时间
- 短信内容变量灵活，方便支持多场景
- 支持多种推广内容的短信发放，例如业务推广、新产品宣讲、会员关怀等内容的短信
- 多维度数据统计-查看请求量、发送成功量、失败量、等

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-19-10-54-image.png)

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-19-11-12-image.png)

#### 获取手机短信验证码接口开发-常规思路

1. 判断当前时间离上次请求短信验证码有60s没

2. 判断有无图形验证码，有判断正确不

3. 发送手机验证码 + redis 进行存储

4. 删除图形验证码

```js
sendCode: async (phone, captcha, type, key, randomCode) => {
    // -------------》方案1
    // // 60秒内不能重复获取
    // if (await redisConfig.exists(`${type}:over:` + phone)) {
    //   return { code: -1, msg: '60秒内不能重复获取' }
    // }

    // -------------》方案2
    if (await redisConfig.exists(`${type}:code:` + phone)) {
      let dateRedis = dayjs(Number((await redisConfig.get(`${type}:code:` + phone)).split('_')[0]))
      if (dayjs(Date.now()).diff(dateRedis, 'second') <= 60) {
        return { code: -1, msg: '60秒内不能重复获取' }
      }
    }

    // 是否有图形验证
    if (!(await redisConfig.exists(`${type}:captcha:` + key))) {
      return { code: -1, msg: '请发送图形验证码' }
    }

    // 对比用户的图形验证码和redis储存的是否一致
    let captchaRedis = await redisConfig.get(`${type}:captcha:` + key)
    if (!(captcha.toLowerCase() === captchaRedis.toLowerCase())) {
      return { code: -1, msg: '图形验证码错误' }
    }

    // 发送手机验证码
    let codeRes = (await aliyunMessage(phone, randomCode)).data

    // -------------》方案1
    // // 验证码存入redis
    // redisConfig.set(`${type}:code:` + phone, randomCode, 600)

    // // 存60秒判断的key
    // redisConfig.set(`${type}:over:` + phone, '1', 60)

    // -------------》方案2
    // 获取当前时间拼接验证码
    let randomCodeTime = `${Date.now()}_${randomCode}`
    redisConfig.set(`${type}:code:` + phone, randomCodeTime, 600)

    // 删除图形验证码
    redisConfig.del(`${type}:captcha:` + key)

    if (codeRes.code == '0') {
      return { code: 0, msg: '发送成功' }
    } else {
      return { code: -1, msg: '发送失败' }
    }
  }
```

第一种使用redis存储60s倒计时和验证码。优化方案：使用redis 将当前时间存在拼接字符串。

第一种使用了2次redis 第二种使用了一次，并且将时间拼接在里面了。

```js
 // 获取当前时间拼接验证码
 let randomCodeTime = `${Date.now()}_${randomCode}`
 redisConfig.set(`${type}:code:` + phone, randomCodeTime, 600)
```

优化方案

- 必须保证两个redis操作的原子性
- 同时减少命名空间的浪费

### 手机短信验证码方式开发注册接口

1. 手机号注册查重的逻辑 

2. 获取redis缓存的code,判断用户code是否正确  

3. 随机获取头像、用户名 -> 加密生成token 7天过期 （封装了一个静态表使用随机数获得头像图片）

4. 用户信息插入数据库

### 封装工具类实现返回状态统一管理

使用映射表规范状态码

一共4种

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-19-22-11-image.png)

### 小滴云在线教育平台PC端-注册模块开发【前端】

antd ssr闪烁

https://ant.design/docs/react/customize-theme-cn#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93

https://github.com/ant-design/ant-design/issues/41573

前端注册页面倒计时开发

<img title="" src="file:///Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-19-25-41-image.png" alt="" width="252">

##### 开发遇到的困难

    倒计时和图形验证码同一组件下，会出现更新倒计时时不断刷新图形验证码，将倒计时设置为子组件实现。更新视图使用useRef使用无效。

    自定义hooks倒计时，遇到倒计时卡住不动的原因  (不能直接传入一个时间，这样从新渲染之后，又会传入新的时间，一个将要传入的时间用usestate包裹起来，在传入hooks)-> 参考ahooks实现倒计时功能。

#### 你在项目中ts使用了哪些地方

##### api接口的返回参数通过TS类型声明强校验

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-20-15-48-image.png)

##### 引入别名

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-13-21-30-16-image.png)

## 登录、注册、忘记

注册：

1. 手机号查重

2. 验证码是否存在，是否正确

3. 数据库新建user 返回token

登录：

- 判空，必须有phone （code or pwd）

- 手机号是否注册

- 验证码是否存在，是否正确

- 数据库返回user 返回token

忘记：

1. 验证码是否存在，是否正确

2. md5加密pwd 更新user

```js
  register: async (phone, code) => {
    // 手机号注册查重
    let existPhone = await DB.Account.findAll({ where: { phone } })
    if (existPhone.length > 0) {
      return BackCode.buildResult(CodeEnum.ACCOUNT_REPEAT)
    }

    // 获取redis中的验证码和用户传入的进行对比
    if (await redisConfig.exists('register:code:' + phone)) {
      let codeRes = (await redisConfig.get('register:code:' + phone)).split('_')[1]
      if (!(code == codeRes)) {
        return BackCode.buildError({ msg: '短信验证码不正确' })
      }
    } else {
      return BackCode.buildError({ msg: '请先获取短信验证码' })
    }

    // 随机生成头像和昵称
    let avatar = RandomTool.randomAvatar()
    let name = RandomTool.randomName()

    // 将用户信息插入数据库
    let id = (await DB.Account.create({ username: name, head_img: avatar, phone })).toJSON().id

    // 生成token 7天过期
    let user = { id, avatar, name, phone }
    console.log(user)
    let token = SecretTool.jwtSign(user, '168h')

    return BackCode.buildSuccessAndData({ data: `Bearer ${token}` })
  },
  forget: async (req) => {
    let { phone, password, code } = req.body
    // 判断code在redis中是否存在
    let codeExist = await redisConfig.exists('change:code:' + phone)
    if (!codeExist) return BackCode.buildError({ msg: '请先获取手机验证码' })
    // 判断redis中code和用户code是否相等
    let codeRes = (await redisConfig.get('change:code:' + phone)).split('_')[1]
    if (!(code === codeRes)) return BackCode.buildError({ msg: '手机验证码不正确' })

    pwd = SecretTool.md5(password)
    await DB.Account.update({ pwd }, { where: { phone } })
    return BackCode.buildSuccessAndMsg({ msg: '修改成功' })
  },
  login: async (req) => {
    let { phone, password, code } = req.body
    // 参数判空
    if (!(phone && (password || code))) return BackCode.buildError({ msg: '缺少必要参数' })
    // 判断手机号是否注册
    let userInfo = await DB.Account.findAll({ where: { phone }, raw: true })
    if (userInfo.length === 0) return BackCode.buildResult(CodeEnum.ACCOUNT_UNREGISTER)

    // 账号密码方式
    if (password) {
      // 判断密码是否正确
      if (!(userInfo[0].pwd == SecretTool.md5(password))) {
        return BackCode.buildResult(CodeEnum.ACCOUNT_PWD_ERROR)
      }
    } else { // 验证码方式
      // 判断redis中是否有login的code
      let codeExist = await redisConfig.exists('login:code:' + phone)
      if (!codeExist) return BackCode.buildError({ msg: '请先获取手机验证码' })
      // redis中code和用户传如的code对比
      let codeRes = (await redisConfig.get('login:code:' + phone)).split('_')[1]
      if (!(codeRes == code)) return BackCode.buildError({ msg: '手机验证码不正确' })
    }
    // 拼接token的用户信息，除去密码
    let user = { ...userInfo[0], pwd: '' }
    //生成token
    let token = SecretTool.jwtSign(user, '168h')
    return BackCode.buildSuccessAndData({ data: `Bearer ${token}` })
  },
```

## 面试题：关联查询和多次单表查询哪个更消耗性能？

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-12-21-54-50-image.png)

关联查询 = 笛卡尔积 + 连接条件 + 其他的查询条件 （结果不出现笛卡尔积，但是查询的计算方式还是有笛卡尔积）

**结论**

因此，在数据量大的业务场景下，两个方式的查询性能损耗肯定是关联查询高，应该少用，或者将查询的数据储存在redis缓存。

##### 分类查找视频接口，等等接口逻辑查看文档，课程章集+用户评论列表模块开发

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-13-12-40-45-image.png)

```js
  query_by_cid: async (req) => {
    let { cpid, cid, page, size } = req.body
    if (!(page && size)) return BackCode.buildError({ msg: '缺少必要的参数' })

    // 当前从第几个算起
    page = (page - 1) * size

    // 判断分类和方向是否为空
    let sqlId = cid || cpid || null

    // 原始的关联查询课程列表
    let productListSql = `SELECT p.* FROM product p LEFT JOIN category_product c ON c.product_id=p.id ${sqlId ? 'WHERE c.category_id=?' : ''} group by p.id ORDER BY p.gmt_create DESC LIMIT ?,?`

    // 传递几个参数进sql判断
    let productListQuery = sqlId ? [sqlId, Number(page), Number(size)] : [Number(page), Number(size)]

    // sequelize原始查询
    let productList = await DB.sequelize.query(productListSql, {
      replacements: productListQuery,
      type: QueryTypes.SELECT
    })

    // 通过子查询课程总数
    let totalSql = `select count(*) as total_record from (SELECT p.id FROM product p LEFT JOIN category_product c ON c.product_id=p.id ${sqlId ? 'WHERE c.category_id=?' : ''} group by p.id) temp_table`

    // sequelize原始查询总数
    let totalRes = await DB.sequelize.query(totalSql, {
      replacements: [sqlId],
      type: QueryTypes.SELECT
    })

    // 总数
    let total_record = totalRes[0].total_record

    // 计算总页数
    let total_page = null
    total_record / size == 0 ? (total_page = total_record / size) : (total_page = Math.ceil(total_record / size))

    return BackCode.buildSuccessAndData({ data: { current_data: productList, total_page, total_record } })
  },
```

## 微信支付

我使用的是第三方Navtive支付

#### 非对称加密技术

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-13-14-19-58-image.png)

##### 哈希计算

![](/Users/mohaixiao/Library/Application%20Support/marktext/images/2023-08-13-14-23-44-image.png)

#### **轮询调用订单状态查询接口的开发**,**课程热销排行榜接口开发** (略)

#### 用户观看视频时长记录，**用户观看视频总时长统计更新**，**用户观看时长排行接口开发(略)**

## 高级前端性能优化-图片优化+缓存+性能监控

## 后台项目

##### **后台管理系统管理员权限**

- 登录权限校验
  
  ```js
  // 管理员权限校验
  const checkIsAdmin = (req, res, next) => {
   // 判断有没有登录
   if (req.headers.authorization) {
     let token = req.headers.authorization.split(' ').pop()
     let userInfo = SecretTool.jwtVerify(token)
     // 登录了判断相关权限是否正确
     if (userInfo && userInfo.role === 'ADMIN') {
       next()
       return
    }
  
     res.send(BackCode.buildError(CodeEnum.ADMIN_NOT_ROLE))
  } else {
     res.send(BackCode.buildError(CodeEnum.ACCOUNT_UNLOGIN))
  }
  }
  ```

##### 自定义封装Sequelize分页和条件查询请求

```js
const { Op } = require('sequelize')
class DBTool {
  /**
   * 根据查询参数对模型进行分页查询
   * @param {*} model Sequelize模型
   * @param {*} options 查询的参数
   * @returns 查询的结果
   */
  static async paginate(model, options) {
    const { page, size } = options
    const offset = Number((page - 1) * size)
    const limit = Number(size)
    const { count, rows } = await model.findAndCountAll({ ...options, offset, limit })
    // 计算总页数
    let total_pages = null
    count / size == 0 ? (total_pages = count / size) : (total_pages = Math.ceil(count / size))
    return { current_data: rows, total_record: count, total_pages }
  }


  /**
   * 生成查询的参数
   * @param {*} condition 查询的条件 -> id绝对查询，其他的根据searchFields模糊匹配
   * @param {*} searchFields 模糊匹配的查询字段
   * @param {*} gmt_start 查询的开始时间段
   * @param {*} gmt_end 查询的结束时间段
   * @returns 查询的参数
   */
  static generateWhereOptions({ condition, gmt_start, gmt_end, searchFields }) {
    let whereOptions = { del: 0 }

    // 判断是否有查询条件
    if (condition) {
      // 如果有查询条件就将其合并到whereOptions中
      whereOptions = {
        [Op.and]: [
          { del: 0 },
          {
            // id为绝对匹配，其他的根据searchFields模糊匹配
            [Op.or]: [
              { id: condition },
              ...searchFields.map((item) => {
                return {
                  [item]: {
                    [Op.like]: `%${condition}%`
                  }
                }
              })
            ]
          }
        ]
      }
    }

    // 如果有开始时间和结束时间
    if (gmt_start && gmt_end) {
      // 将之前的条件和时间合并
      // 之前的条件为必要条件，时间条件则是在gmt_create和gmt_modified的任意包括值
      whereOptions = {
        [Op.and]: [
          whereOptions,
          {
            [Op.or]: [
              {
                gmt_create: {
                  [Op.between]: [gmt_start, gmt_end]
                }
              },
              {
                gmt_modified: {
                  [Op.between]: [gmt_start, gmt_end]
                }
              }
            ]
          }
        ]
      }
      // 如果只有开始时间
    } else if (gmt_start) {
      // 将之前的条件和时间合并
      // 之前的条件为必要条件，时间条件则是在gmt_create和gmt_modified的任意开始值
      whereOptions = {
        [Op.and]: [
          whereOptions,
          {
            [Op.or]: [
              {
                gmt_create: {
                  [Op.gte]: gmt_start
                }
              },
              {
                gmt_modified: {
                  [Op.gte]: gmt_start
                }
              }
            ]
          }
        ]
      }
      // 如果只有结束时间条件
    } else if (gmt_end) {
      // 将之前的条件和时间合并
      // 之前的条件为必要条件，时间条件则是在gmt_create和gmt_modified的任意结束值
      whereOptions = {
        [Op.and]: [
          whereOptions,
          {
            [Op.or]: [
              {
                gmt_create: {
                  [Op.lte]: gmt_end
                }
              },
              {
                gmt_modified: {
                  [Op.lte]: gmt_end
                }
              }
            ]
          }
        ]
      }
    }

    return whereOptions
  }
}

module.exports = DBTool
```

## SQL 安装完成后，关闭mysql 的 ONLY_FULL_GROUP_BY模式（不然线上运行sql中的group by分组语句会报错）

解决方案一：在查询语句中加入所有未聚合的列

这个方案需要修改查询语句，将所有列都加入到Group By子句中，比如将查询语句修改为以下形式：

```
SELECT p.*, c.category_id FROM product p LEFT JOIN category_product c ON c.product_id=p.id GROUP BY p.id, c.category_id ORDER BY p.gmt_create DESC LIMIT 0,12
```

解决方案二：关闭only_full_group_by模式

可以通过修改MySQL的配置文件或者直接在SQL查询中来关闭only_full_group_by模式。

修改MySQL的配置文件方式：

1. 打开MySQL的配置文件，找到 [mysqld] 段落。
2. 在 [mysqld] 段落中添加一行代码：sql_mode=''
3. 保存配置文件并重启MySQL服务。

直接在SQL查询中关闭only_full_group_by模式：

1. 连接MySQL数据库，执行以下命令：

```
SET GLOBAL sql_mode='';
```

注意：该方法需要有足够的权限才能执行。

2. 然后再执行查询语句即可。

注意事项：虽然关闭only_full_group_by模式可以解决问题，但是也会带来潜在的风险，因为它放宽了MySQL数据库对于Group By的限制，可能会导致查询结果不准确。因此建议使用方案一对查询语句进行改进以符合MySQL的标准规范。

### 视频播放

播放页面，点开章节自动播放。

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-06-30-15-21-53-image.png)

数据库插入华为云id

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-06-30-16-27-55-image.png)

Uncaught (in promise) DOMException: play() failed because the user didn't interact with the document first.

这个错误通常是由于浏览器的自动播放策略所引起的。大多数现代浏览器要求在播放音频或视频之前，用户必须与页面进行交互。

为了解决这个问题，您可以采取以下措施：

1. 确保音频的播放方法被用户的交互事件触发，例如点击按钮或其他用户操作。
2. 在页面加载完成后，通过一个用户操作（例如点击按钮）来触发音频的播放。
3. 使用浏览器支持的自动播放配置选项，如 `autoplay` 属性或 `muted` 属性。请注意，使用自动播放功能可能会遭到浏览器的阻止，除非用户已与页面进行过有效的交互。

根据具体情况，您可以选择适合您需求和用户体验的解决方案。希望这些提示能帮助您解决该错误。如有其他问题，请随时提问。

Play组件渲染接受的chapterList 是空数组。

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-01-12-57-38-image.png)

使用useRef暴露方法

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-01-14-22-57-image.png)

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-01-14-23-09-image.png)

### children怎么传递参数

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-05-20-21-26-image.png)

如果你的子组件是一个`<div>`元素，你可以使用React的`cloneElement`函数来传递props。这样可以将父组件的props传递给子组件。

```jsx
const Danmu = ({ children, ...props }) => {
  // 将父组件的props传递给子组件
  const clonedChildren = React.cloneElement(children, props);

  return (
    <div
      id="container"
      style={{ height: "100%", width: "100%" }}
      className="absolute left-[15%] top-[0%] flex items-center w-[90%] h-[100%]"
    >
      {clonedChildren}
    </div>
  );
};
```

在父组件中，你可以这样使用`Danmu`组件，并传递props给子组件：

```jsx
<Danmu prop1={value1} prop2={value2}>
  <div>
    {/* 子组件的内容 */}
  </div>
</Danmu>
```

在这个例子中，`prop1`和`prop2`会被传递给子组件中的`<div>`元素作为props。你也可以在子组件中使用`props.prop1`和`props.prop2`来获取这些传递的值。

react 先渲染子组件，在渲染父组件，调用下一集是父组件调用，获取最新弹幕是子组件调用，id就不一致。

闭包问题：绑定事件拿不到最新的id

![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-07-12-39-31-image.png)

使用useLatest获取最新值![](C:\Users\mohaixiao\AppData\Roaming\marktext\images\2023-07-07-12-39-49-image.png)

### 获取视频播放记录接口开发

useState的值只有第一次渲染的时候才会存在，其他时候不会使用

1快速融入：团队迎新，安排师兄带，安排小需求，设置转正目标，快速熟悉业务。

2如何保证团队的业务稳定运行：可监控，可灰度，可回滚 不允许三无发布，定期codereview，应急响应，查看日志

3项目事故怎么解决：线上官网崩溃，显示白屏，阿里云服务器资源占有，容器未删除。解决：增加阿里云监控报警，自动化部署设置，测试审核验证后发邮件通知

4项目中的服务器配置和接口性能是怎么样的：

5服务器配置

阿里云ECS服务器，8核16G，磁盘200G/台，宽带（按量付费），视频宽带vode（按量付费）
查询
不使用缓存，大概1~3千的qps 
使用缓存，大概2-4万的qps
涉及到事务操作的增删改
大概5百~1千的tps
前端项目：4台
后端项目：4台
mysql：2台（集群）
redis：2台（集群）
rabbitmq：2台（集群）
nginx：2台（集群）
开发周期
1-2个月开发初版
2周迭代一个版本

6 项目可以支撑多少并发前端和后端？ 项目的难点和业务哪里比较复杂？解决方案？如果改进有哪些地方可以做的更好？

技术栈

熟练掌握 HTML、CSS、JavaScript等 Web 前端基础技术熟练掌握 ECMAScript 6 语法特性 、TypeScript静态类型检查熟练掌握 CSS 预处理器，Unocss 框架提高开发效率
熟练掌握 Vue3 框架和 Vue 全家桶，MVVM、虚拟 DOM和 Diff 算法熟悉 Nuxt3 框架开发服务端渲染项目优化页面 SEO
熟悉 React框架
·熟悉 Webpack5 构建工具优化包体积性能、Vite、Babel 技术

熟悉 Git 代码管理工具、GitHub 和 Gitee 远程仓库
熟悉第三方组件库的使用封装: Element-plus、Ant-Design、Echarts
熟悉常用的 Linux命令、Docker 容器部署、Nginx 反向代理服务器

·熟悉 Mysql使用、ORM框架 Sequelize 提高开发效率
熟悉 Express 框架开发后端接口，具有后端开发经验
熟悉 Redis 缓存、自定义 Key、发布订阅
熟悉 RabbitMQ 死信队列实现订单延时关单
熟悉结合 Docker+Gitee Go 实现 DevOps

熟悉阿里云服务器+域名+https 配置+OSS 加速图片资源
熟悉 Videojs 视频插件、华为云视频 Vod
熟悉微信支付领域和 Oauth2.0 登录

#### 封装成共用方法，有什么注意事项？如何做到共用方法的可扩展性